/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _src_snowblind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/snowblind.js */ \"./src/snowblind.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_src_snowblind_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://@snowblind/core/./index.js?");

/***/ }),

/***/ "./modules/hooks/index.js":
/*!********************************!*\
  !*** ./modules/hooks/index.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useDisclosure\": () => (/* reexport safe */ _useDisclosure_js__WEBPACK_IMPORTED_MODULE_4__.useDisclosure),\n/* harmony export */   \"useEffect\": () => (/* reexport safe */ _useEffect_js__WEBPACK_IMPORTED_MODULE_1__.useEffect),\n/* harmony export */   \"useInputState\": () => (/* reexport safe */ _useInputState_js__WEBPACK_IMPORTED_MODULE_0__.useInputState),\n/* harmony export */   \"useQueue\": () => (/* reexport safe */ _useQueue_js__WEBPACK_IMPORTED_MODULE_5__.useQueue),\n/* harmony export */   \"useRef\": () => (/* reexport safe */ _useRef_js__WEBPACK_IMPORTED_MODULE_3__.useRef),\n/* harmony export */   \"useState\": () => (/* reexport safe */ _useState_js__WEBPACK_IMPORTED_MODULE_2__.useState),\n/* harmony export */   \"useToggle\": () => (/* reexport safe */ _useToggle_js__WEBPACK_IMPORTED_MODULE_6__.useToggle),\n/* harmony export */   \"useTransition\": () => (/* reexport safe */ _useTransition_js__WEBPACK_IMPORTED_MODULE_7__.useTransition),\n/* harmony export */   \"useValidatedState\": () => (/* reexport safe */ _useValidatedState_js__WEBPACK_IMPORTED_MODULE_8__.useValidatedState)\n/* harmony export */ });\n/* harmony import */ var _useInputState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useInputState.js */ \"./modules/hooks/useInputState.js\");\n/* harmony import */ var _useEffect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useEffect.js */ \"./modules/hooks/useEffect.js\");\n/* harmony import */ var _useState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useState.js */ \"./modules/hooks/useState.js\");\n/* harmony import */ var _useRef_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useRef.js */ \"./modules/hooks/useRef.js\");\n/* harmony import */ var _useDisclosure_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useDisclosure.js */ \"./modules/hooks/useDisclosure.js\");\n/* harmony import */ var _useQueue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./useQueue.js */ \"./modules/hooks/useQueue.js\");\n/* harmony import */ var _useToggle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./useToggle.js */ \"./modules/hooks/useToggle.js\");\n/* harmony import */ var _useTransition_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./useTransition.js */ \"./modules/hooks/useTransition.js\");\n/* harmony import */ var _useValidatedState_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./useValidatedState.js */ \"./modules/hooks/useValidatedState.js\");\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://@snowblind/core/./modules/hooks/index.js?");

/***/ }),

/***/ "./modules/hooks/useDisclosure.js":
/*!****************************************!*\
  !*** ./modules/hooks/useDisclosure.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useDisclosure\": () => (/* binding */ useDisclosure)\n/* harmony export */ });\n/* harmony import */ var _useState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useState.js */ \"./modules/hooks/useState.js\");\n\n\n/**\n * Hook to help with boolean checks, providing callbacks to handle modal open/close events.\n * @param {boolean} initialValue The value to start with, either `true` or `false`\n * @param {Object<onOpen?, onClose?>} callbacks Callbacks to handle a close or open event\n * @returns [opened, {open, close, toggle}]\n */\nfunction useDisclosure(initialValue, callbacks) {\n\tconst [opened, setOpened] = (0,_useState_js__WEBPACK_IMPORTED_MODULE_0__.useState)(initialValue);\n\n\tconst open = () => {\n\t\tif (!opened) {\n\t\t\tsetOpened(true);\n\t\t\tcallbacks?.onOpen?.();\n\t\t}\n\t};\n\n\tconst close = () => {\n\t\tif (opened) {\n\t\t\tsetOpened(false);\n\t\t\tcallbacks?.onClose?.();\n\t\t}\n\t};\n\n\tconst toggle = () => {\n\t\topened ? close() : open();\n\t};\n\n\treturn [opened, {\n\t\topen,\n\t\tclose,\n\t\ttoggle\n\t}];\n}\n\n\n\n//# sourceURL=webpack://@snowblind/core/./modules/hooks/useDisclosure.js?");

/***/ }),

/***/ "./modules/hooks/useEffect.js":
/*!************************************!*\
  !*** ./modules/hooks/useEffect.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useEffect\": () => (/* binding */ useEffect)\n/* harmony export */ });\n/* harmony import */ var _src_shared_internals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/shared-internals.js */ \"./src/shared-internals.js\");\n/* harmony import */ var _utils_deepCompare_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/deepCompare.js */ \"./modules/utils/deepCompare.js\");\n\n\n\nfunction useEffect(callback, stateConditional = []) {\n\t/**\n\t * Store original values to compare against later on, if one updated render the component again.\n\t */\n\tvar originalValues = stateConditional.map(x => x.valueOf());\n\n\t/**\n\t * Exit the main event loop and enter a subscribe function to stagger execution of subscription.\n\t */\n\t_src_shared_internals_js__WEBPACK_IMPORTED_MODULE_0__.UpdateDispatcher.subscribe((value) => {\n\t\tconst runCallback = () => {\n\t\t\tif (originalValues.length > 0) {\n\t\t\t\t/**\n\t\t\t\t * Compare values on rerender.\n\t\t\t\t */\n\t\t\t\tif (originalValues.filter((x, i) => !(0,_utils_deepCompare_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(x, stateConditional[i].valueOf())).length > 0) {\n\t\t\t\t\tcallback();\n\t\t\t\t\toriginalValues = stateConditional.map(x => x.valueOf());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/**\n\t\t\t\t * Always call the passed callback\n\t\t\t\t */\n\t\t\t\tcallback()\n\t\t\t}\n\t\t}\n\t\tvalue.onComponentDidMount(runCallback);\n\t\tvalue.onComponentDidUpdate(runCallback);\n\t})\n}\n\n\n\n//# sourceURL=webpack://@snowblind/core/./modules/hooks/useEffect.js?");

/***/ }),

/***/ "./modules/hooks/useInputState.js":
/*!****************************************!*\
  !*** ./modules/hooks/useInputState.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useInputState\": () => (/* binding */ useInputState)\n/* harmony export */ });\n/* harmony import */ var _useState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useState.js */ \"./modules/hooks/useState.js\");\n\n\n/**\n * Shorthand for the `event.currentTarget.value` syntax that would have to be used with inputs normally.\n * @param {any} initialValue The value to initialize the state with.\n * @returns [value, changeEvent]\n */\nfunction useInputState(initialValue) {\n\tconst [value, setValue] = (0,_useState_js__WEBPACK_IMPORTED_MODULE_0__.useState)(initialValue);\n\tconst changeEvent = (evt) => setValue(evt.currentTarget.value);\n\n\treturn [value, changeEvent];\n}\n\n\n\n//# sourceURL=webpack://@snowblind/core/./modules/hooks/useInputState.js?");

/***/ }),

/***/ "./modules/hooks/useQueue.js":
/*!***********************************!*\
  !*** ./modules/hooks/useQueue.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useQueue\": () => (/* binding */ useQueue)\n/* harmony export */ });\n/* harmony import */ var _useState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useState.js */ \"./modules/hooks/useState.js\");\n\n\n/**\n * Sort items into a queue to use later\n * @param {Integer} limit The maximum number of items to stay in the state array at the same time.\n * @param {Array<any>} initialValues An array of initials to fill state and queue with.\n * @returns {state, queue, add, shift, update, cleanQueue}\n */\nfunction useQueue(limit, initialValues = []) {\n\tconst makeState = (r) => ({\n\t\tstate: r.slice(0, limit),\n\t\tqueue: r.slice(limit)\n\t})\n\n\tconst [{\n\t\tstate,\n\t\tqueue\n\t}, setState] = (0,_useState_js__WEBPACK_IMPORTED_MODULE_0__.useState)({\n\t\tstate: initialValues.slice(0, limit),\n\t\tqueue: initialValues.slice(limit)\n\t})\n\n\tconst shift = () => {\n\t\tvar shiftedItem;\n\t\tsetState(current => {\n\t\t\tlet results = [...current.state, ...current.queue];\n\t\t\tshiftedItem = results.shift();\n\t\t\treturn makeState(results)\n\t\t})\n\t\treturn shiftedItem;\n\t}\n\n\tconst add = (...els) => {\n\t\tsetState(current => {\n\t\t\tlet results = [...current.state, ...current.queue, ...els];\n\t\t\treturn makeState(results)\n\t\t})\n\t}\n\n\tconst update = (fn) => {\n\t\tsetState(current => {\n\t\t\tlet results = fn([...current.state, ...current.queue]);\n\t\t\treturn makeState(results)\n\t\t})\n\t}\n\n\tconst cleanQueue = () => setState(current => ({\n\t\tstate: current.state,\n\t\tqueue: []\n\t}));\n\n\treturn {\n\t\tstate,\n\t\tqueue,\n\t\tadd,\n\t\tshift,\n\t\tupdate,\n\t\tcleanQueue\n\t}\n}\n\n\n\n//# sourceURL=webpack://@snowblind/core/./modules/hooks/useQueue.js?");

/***/ }),

/***/ "./modules/hooks/useRef.js":
/*!*********************************!*\
  !*** ./modules/hooks/useRef.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useRef\": () => (/* binding */ useRef)\n/* harmony export */ });\nfunction useRef() {\n\tclass SnowblindRef {\n\t\tconstructor() {\n\t\t\tthis.current = undefined;\n\t\t}\n\t}\n\treturn new SnowblindRef();\n}\n\n\n\n//# sourceURL=webpack://@snowblind/core/./modules/hooks/useRef.js?");

/***/ }),

/***/ "./modules/hooks/useState.js":
/*!***********************************!*\
  !*** ./modules/hooks/useState.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useState\": () => (/* binding */ useState)\n/* harmony export */ });\n/* harmony import */ var _src_shared_internals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/shared-internals.js */ \"./src/shared-internals.js\");\n\n\n/**\n * Defines a state variable to be used for values inside the DOM, re-renders once it's value changes.\n * @param {any} state A value used as a state to the current render cycle.\n * @param {boolean} bind Whether to bind the state to a render instance\n * @returns {Array<any, function>} A pair of getter and setter to access the state.\n */\nfunction useState(state, bind = true) {\n\tconst obs = new _src_shared_internals_js__WEBPACK_IMPORTED_MODULE_0__.Observable(state);\n\tvar value = new _src_shared_internals_js__WEBPACK_IMPORTED_MODULE_0__.ValueBinder(obs)\n\tif (bind === true) {\n\t\t_src_shared_internals_js__WEBPACK_IMPORTED_MODULE_0__.UpdateDispatcher.subscribe((component) => {\n\t\t\tconst renderer = component.Renderer;\n\t\t\tobs.subscribe(() => {\n\t\t\t\trenderer.Render();\n\t\t\t})\n\t\t})\n\t}\n\n\tconst _callback = (newState) => {\n\t\tif (typeof newState === 'function') {\n\t\t\t// Execute a function to get the next values;\n\t\t\tnewState = newState();\n\t\t}\n\t\tnewState = newState.valueOf()\n\t\tobs.next(newState)\n\t\treturn newState\n\t}\n\treturn [value, _callback]\n}\n\n\n\n//# sourceURL=webpack://@snowblind/core/./modules/hooks/useState.js?");

/***/ }),

/***/ "./modules/hooks/useToggle.js":
/*!************************************!*\
  !*** ./modules/hooks/useToggle.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useToggle\": () => (/* binding */ useToggle)\n/* harmony export */ });\n/* harmony import */ var _useState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useState.js */ \"./modules/hooks/useState.js\");\n\n\n/**\n * Toggle through a list of options.\n * @param {any} initialValue The first value the function shall use.\n * @param {Array<any>} options A list of options to choose from.\n * @returns {Array<any, Function>} An array consisting of the value, on the first call it'll be the initial value and a toggle function to loop through the possibilities starting at the index of the initial value.\n */\nfunction useToggle(initialValue, options) {\n\tlet index = options.indexOf(initialValue);\n\tconst [value, setValue] = (0,_useState_js__WEBPACK_IMPORTED_MODULE_0__.useState)(initialValue);\n\tconst mimicSetValue = () => {\n\t\t// Let the index wrap back around.\n\t\tindex = (index == options.length - 1) ? 0 : index + 1;\n\t\tlet value = options[index]\n\t\tsetValue(value)\n\t}\n\treturn [value, mimicSetValue]\n}\n\n\n\n//# sourceURL=webpack://@snowblind/core/./modules/hooks/useToggle.js?");

/***/ }),

/***/ "./modules/hooks/useTransition.js":
/*!****************************************!*\
  !*** ./modules/hooks/useTransition.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useTransition\": () => (/* binding */ useTransition)\n/* harmony export */ });\n/* harmony import */ var _src_shared_internals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/shared-internals.js */ \"./src/shared-internals.js\");\n\n\nfunction useTransition(obj, options) {\n\t_src_shared_internals_js__WEBPACK_IMPORTED_MODULE_0__.UpdateDispatcher.subscribe((component) => {\n\t\t/**\n\t\t * Animates the render cycle given CSS properties\n\t\t */\n\t\toptions = Object.assign({\n\t\t\tdelay: 0,\n\t\t\tduration: 400,\n\t\t\tmaxCopies: Infinity,\n\t\t\ttimingFunction: (t, b, c, d) => {\n\t\t\t\t// Default easeInOutSine function\n\t\t\t\treturn -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n\t\t\t}\n\t\t}, options)\n\t\tcomponent._maxCopies = options.maxCopies;\n\t\tcomponent._usesTransition = true;\n\t\tconst animateChange = (from, to, nodes) => {\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tconst startTime = performance.now()\n\t\t\t\t\tconst matchRegExp = new RegExp(/([0-9.-]+)([A-z%]+)?/g)\n\t\t\t\t\tconst convert = (i) => [undefined, null].indexOf(i) == -1 && i.toString().matchAll(matchRegExp);\n\t\t\t\t\tconst interval = (lastExpectedCycle) => {\n\t\t\t\t\t\tconst elapsed = performance.now() - startTime;\n\t\t\t\t\t\tif (elapsed >= options.duration) {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Run one last time to clear lastly updated properties\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (!lastExpectedCycle) {\n\t\t\t\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\t\t\t\tinterval(true)\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\t\t\tinterval(false)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const i in to) {\n\t\t\t\t\t\t\tvar end = Array.from(convert(to[i]));\n\t\t\t\t\t\t\tif ([undefined, null].indexOf(from[i]) == -1) {\n\t\t\t\t\t\t\t\tvar j = 0;\n\t\t\t\t\t\t\t\tvar replaced = from[i].toString().replace(matchRegExp, (x, num, unit) => {\n\t\t\t\t\t\t\t\t\tnum = parseFloat(num)\n\t\t\t\t\t\t\t\t\tvar _to = parseFloat(end[j][1])\n\t\t\t\t\t\t\t\t\tj++\n\t\t\t\t\t\t\t\t\tvar standardUnit = ([\"color\", \"background\", \"background-color\"].indexOf(i) === -1) ? \"px\" : \"\"\n\t\t\t\t\t\t\t\t\treturn options.timingFunction(elapsed, num, _to - num, options.duration).toString() + (unit || end[j - 1][2] || standardUnit)\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\tfor (const node of nodes) {\n\t\t\t\t\t\t\t\t\tnode[0].style[i] = replaced\n\t\t\t\t\t\t\t\t\tif (lastExpectedCycle) {\n\t\t\t\t\t\t\t\t\t\tnode[0].style[i] = to[i]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\tinterval(false)\n\t\t\t\t\t})\n\t\t\t\t}, options.delay)\n\t\t\t})\n\t\t}\n\t\tcomponent.transitionFunction = {\n\t\t\tfrom: (callback) => {\n\t\t\t\tfor (const i in obj.from) {\n\t\t\t\t\tcomponent.Node.style[i] = obj.from[i];\n\t\t\t\t}\n\t\t\t\tcallback()\n\t\t\t},\n\t\t\trender: (callback) => {\n\t\t\t\tanimateChange(obj.render, obj.enter, component.Node).then(callback)\n\t\t\t},\n\t\t\tenter: (callback) => {\n\t\t\t\tanimateChange(obj.from, obj.enter, component.Node).then(callback)\n\t\t\t},\n\t\t\tleave: (callback) => {\n\t\t\t\tanimateChange(obj.enter, obj.leave, component.Node).then(callback)\n\t\t\t}\n\t\t}\n\t})\n}\n\n\n\n//# sourceURL=webpack://@snowblind/core/./modules/hooks/useTransition.js?");

/***/ }),

/***/ "./modules/hooks/useValidatedState.js":
/*!********************************************!*\
  !*** ./modules/hooks/useValidatedState.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useValidatedState\": () => (/* binding */ useValidatedState)\n/* harmony export */ });\n/* harmony import */ var _useState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useState.js */ \"./modules/hooks/useState.js\");\n\n\n/**\n * Tests on every new value, whether it matches a certain condition, useful for boolean checks.\n * @param {any} initialValue The value to initialize with\n * @param {function} validation A function that checks whether a new value passes the validation\n * @returns [{value, lastValidValue, valid}, changeValue]\n */\nfunction useValidatedState(initialValue, validation) {\n\tconst [value, setValue] = (0,_useState_js__WEBPACK_IMPORTED_MODULE_0__.useState)(initialValue);\n\tconst [lastValidValue, setLastValidValue] = (0,_useState_js__WEBPACK_IMPORTED_MODULE_0__.useState)(validation(initialValue) ? initialValue : undefined, false);\n\tconst [valid, setValid] = (0,_useState_js__WEBPACK_IMPORTED_MODULE_0__.useState)(validation(initialValue), false)\n\n\tconst changeValue = (newValue) => {\n\t\tif (validation(newValue)) {\n\t\t\tsetLastValidValue(newValue);\n\t\t\tsetValid(true);\n\t\t} else {\n\t\t\tsetValid(false);\n\t\t}\n\n\t\tsetValue(newValue);\n\t}\n\n\treturn [{\n\t\tvalue,\n\t\tlastValidValue,\n\t\tvalid\n\t}, changeValue]\n}\n\n\n\n//# sourceURL=webpack://@snowblind/core/./modules/hooks/useValidatedState.js?");

/***/ }),

/***/ "./modules/typecheck.js":
/*!******************************!*\
  !*** ./modules/typecheck.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"propTypes\": () => (/* binding */ propTypes),\n/* harmony export */   \"typeCheck\": () => (/* binding */ typeCheck),\n/* harmony export */   \"typeIf\": () => (/* binding */ typeIf)\n/* harmony export */ });\nconst propTypes = new Proxy({\n\tNumber: (x) => typeof x === 'number',\n\tInteger: (x) => (typeof x === 'number') && x % 1 === 0,\n\tBigInt: (x) => typeof x === \"bigint\",\n\tFloat: (x) => (typeof x === \"number\") && x % 1 !== 0,\n\tString: (x) => typeof x === \"string\",\n\tArray: (x) => Array.isArray(x),\n\tObject: (x) => (typeof x === \"object\") && !Array.isArray(x),\n\tSymbol: (x) => typeof x === \"symbol\",\n\tBoolean: (x) => typeof x === \"boolean\",\n\tFunction: (x) => typeof x === \"function\",\n\tnode: (x) => [\"number\", \"string\"].indexOf(typeof x) > -1 || x instanceof HTMLElement || Array.isArray(x),\n\telement: (x) => x instanceof HTMLElement,\n\telementType: (x) => x instanceof undefined.Component,\n\tinstanceOf: function (instance) {\n\t\treturn (x) => x instanceof instance;\n\t},\n\ttypeOf: function (type) {\n\t\treturn (x) => typeof x === type;\n\t},\n\toneOfType: function (types) {\n\t\treturn (x) => {\n\t\t\treturn types.map(y => {\n\t\t\t\treturn typeof y === \"function\" ? y(x) : this[y](x)\n\t\t\t}).indexOf(true) > -1\n\t\t};\n\t},\n\toneOf: function (values) {\n\t\treturn (x) => {\n\t\t\treturn values.indexOf(x) > -1;\n\t\t}\n\t},\n\tarrayOf: function (type) {\n\t\treturn (x) => {\n\t\t\treturn this.Array.isArray(x) ? x.map(y => {\n\t\t\t\ttypeof type === \"function\" ? type(x) : this[type](x)\n\t\t\t}).indexOf(false) === -1 : false\n\t\t};\n\t},\n\tobjectOf: function (type) {\n\t\treturn (x) => {\n\t\t\treturn x ? this.arrayOf(type)(Object.values(x)) : false\n\t\t};\n\t},\n\tshape: function (typeObject) {\n\t\treturn (testObj) => {\n\t\t\t/**\n\t\t\t * Run exact inexactly :)\n\t\t\t */\n\t\t\treturn this.exact(typeObject, true)(testObj)\n\t\t}\n\t},\n\texact: function (typeObject, runInexact = false) {\n\t\treturn (testObj) => {\n\t\t\tif (testObj && typeObject) {\n\t\t\t\tfor (const i in testObj) {\n\t\t\t\t\tif (typeObject.hasOwnProperty(i)) {\n\t\t\t\t\t\tvar compareFunc = typeof typeObject[i] === \"string\" ? this[typeObject[i]] : typeObject[i];\n\t\t\t\t\t\tvar result = compareFunc(testObj[i])\n\t\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\t\treturn result\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!runInexact) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t},\n\tcustomProp: (Func) => {\n\t\treturn Func\n\t},\n\tAny: () => true\n}, {\n\tset: () => false,\n\tget: function (obj, key) {\n\t\tif (obj.hasOwnProperty(key)) {\n\t\t\tvar Func = obj[key];\n\t\t\tFunc.isRequired = function (x, prop) {\n\t\t\t\tif (typeof x === \"undefined\") {\n\t\t\t\t\tthrow new Error(`Encountered undefined prop \"${prop}\" as required object.`)\n\t\t\t\t} else {\n\t\t\t\t\treturn obj[key](x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tFunc.ofLength = function (length) {\n\t\t\t\treturn (x) => {\n\t\t\t\t\treturn obj[key](x) && x.length === length;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Func\n\t\t} else {\n\t\t\tthrow new Error(`Invalid type for property \"${key}\" encountered.`)\n\t\t}\n\t}\n})\n\nconst typeIf = function (value, type, ifTrue, ifFalse) {\n\tvar result = typeCheck({\n\t\tvalue: value\n\t}, {\n\t\tvalue: type\n\t}, {}, {\n\t\treturnBool: true\n\t})\n\treturn result ? ifTrue : ifFalse;\n}\n\nconst typeCheck = function (obj, optPropertyTypes, defaultProps, options) {\n\toptions = Object.assign({\n\t\treturnBool: false\n\t}, options)\n\tobj = Object.assign({}, defaultProps, obj)\n\tvar store = []\n\tif (typeof optPropertyTypes !== 'undefined') {\n\t\tfor (const prop in optPropertyTypes) {\n\t\t\tconst propType = optPropertyTypes[prop];\n\t\t\tconst runFunction = typeof propType === \"function\" ? propType : (propTypes[propType] || (() => false))\n\t\t\tvar Result = runFunction(obj[prop], prop);\n\t\t\tif (Result === false) {\n\t\t\t\tif (options.returnBool) {\n\t\t\t\t\treturn Result;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`Invalid type for property \"${prop}\" encountered.`)\n\t\t\t\t}\n\t\t\t}\n\t\t\tstore.push(Result)\n\t\t}\n\t}\n\tif (options.returnBool && store.indexOf(false) === -1) {\n\t\treturn true\n\t}\n\treturn obj\n}\n\n\n\n//# sourceURL=webpack://@snowblind/core/./modules/typecheck.js?");

/***/ }),

/***/ "./modules/utils/deepCompare.js":
/*!**************************************!*\
  !*** ./modules/utils/deepCompare.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Compares two values for equality.\n * @param {any} x First value to compare\n * @param {any} y Second value to compare\n */\nfunction deepCompare(x, y) {\n\tif (x === y) return true;\n\t// if both x and y are null or undefined and exactly the same\n\n\tif (!(x instanceof Object) || !(y instanceof Object)) return false;\n\t// if they are not strictly equal, they both need to be Objects\n\n\tif (x.constructor !== y.constructor) return false;\n\t// they must have the exact same prototype chain, the closest we can do is\n\t// test their constructor.\n\n\tfor (var p in x) {\n\t\tif (!x.hasOwnProperty(p)) continue;\n\t\t// other properties were tested using x.constructor === y.constructor\n\n\t\tif (!y.hasOwnProperty(p)) return false;\n\t\t// allows to compare x[ p ] and y[ p ] when set to undefined\n\n\t\tif (x[p] === y[p]) continue;\n\t\t// if they have the same strict value or identity then they are equal\n\n\t\tif (typeof (x[p]) !== \"object\") return false;\n\t\t// Numbers, Strings, Functions, Booleans must be strictly equal\n\n\t\tif (!deepCompare(x[p], y[p])) return false;\n\t\t// Objects and Arrays must be tested recursively\n\t}\n\n\tfor (p in y)\n\t\tif (y.hasOwnProperty(p) && !x.hasOwnProperty(p))\n\t\t\treturn false;\n\t// allows x[ p ] to be set to undefined\n\n\treturn true;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (deepCompare);\n\n//# sourceURL=webpack://@snowblind/core/./modules/utils/deepCompare.js?");

/***/ }),

/***/ "./src/html.js":
/*!*********************!*\
  !*** ./src/html.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"choose\": () => (/* binding */ choose),\n/* harmony export */   \"classArray\": () => (/* binding */ classArray),\n/* harmony export */   \"classMap\": () => (/* binding */ classMap),\n/* harmony export */   \"html\": () => (/* binding */ html),\n/* harmony export */   \"range\": () => (/* binding */ range),\n/* harmony export */   \"repeat\": () => (/* binding */ repeat),\n/* harmony export */   \"styleMap\": () => (/* binding */ styleMap),\n/* harmony export */   \"when\": () => (/* binding */ when)\n/* harmony export */ });\n/* harmony import */ var _snowblind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./snowblind.js */ \"./src/snowblind.js\");\n/* harmony import */ var _shared_internals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared-internals.js */ \"./src/shared-internals.js\");\n\n\n\nfunction html(strings, ...vars) {\n\n\tfunction applyEvent(elem, trigger, event, onlyThisNode) {\n\t\telem.addEventListener(trigger, (e) => {\n\t\t\tif (onlyThisNode && e.target.isEqualNode(elem)) {\n\t\t\t\tevent(elem, e)\n\t\t\t} else if (!onlyThisNode) {\n\t\t\t\tevent(elem, e)\n\t\t\t}\n\t\t})\n\t}\n\n\tfunction insertText(elem, text) {\n\t\tvar textElement = document.createTextNode(text);\n\t\telem.appendChild(textElement);\n\t}\n\n\tconst MATCH_INDEX_REGEX = /\\{\\{([0-9]+)\\}\\}/g;\n\tvar result = \"\",\n\t\ti = 0;\n\tfor (const str of strings) {\n\t\tresult += str + (strings[strings.length - 1] === str ? \"\" : `{{${i++}}}`);\n\t}\n\tconst template = document.createElement(\"template\");\n\ttemplate.innerHTML = result;\n\n\t/**\n\t * Limit to one element per fragment, require multiple to be wrapped in another element.\n\t */\n\tif (template.content.children.length > 1) {\n\t\tthrow new Error(\"Multiple elements must be wrapped in a single element.\");\n\t}\n\n\tconst walker = document.createTreeWalker(template.content, 1, null);\n\n\tlet node;\n\tlet foundInputs = 0;\n\n\twhile ((node = walker.nextNode()) !== null) {\n\t\t/**\n\t\t * Check if node is an input or a textarea, if so, set a key for focusing it later on.\n\t\t */\n\t\tif (node instanceof HTMLTextAreaElement || node instanceof HTMLInputElement) {\n\t\t\tif (!node.hasAttribute(\"key\")) {\n\t\t\t\tnode.setAttribute(\"key\", \"inputNo\" + foundInputs);\n\t\t\t\tfoundInputs++\n\t\t\t}\n\t\t}\n\n\t\tfor (const attribute of Array.from(node.attributes)) {\n\t\t\tvar name = attribute.name;\n\t\t\tvar value = attribute.nodeValue;\n\t\t\tvar nameStart = name[0];\n\t\t\tvar realName = name.substring(1)\n\n\t\t\tconst MATCH_MULTI_CHAR = /\\{([@.?!]+)\\}/;\n\n\t\t\tvalue = value.replace(MATCH_INDEX_REGEX, (x, y) => {\n\t\t\t\tvar index = parseInt(y);\n\t\t\t\tvar realValue = vars[index];\n\t\t\t\tvar applyValue = \"\";\n\n\t\t\t\tif (name === \"ref\" && realValue.constructor && realValue.constructor.name === \"SnowblindRef\") {\n\t\t\t\t\t/**\n\t\t\t\t\t * User wants a reference to the current object\n\t\t\t\t\t */\n\t\t\t\t\trealValue.current = node;\n\t\t\t\t\tnode.isReferenceTo = realValue;\n\t\t\t\t\tnode.removeAttribute(\"ref\");\n\t\t\t\t\treturn\n\t\t\t\t} else if (name === \"sx\") {\n\t\t\t\t\t/**\n\t\t\t\t\t * Default style override\n\t\t\t\t\t */\n\t\t\t\t\tif (typeof realValue === \"string\") {\n\t\t\t\t\t\tnode.style = realValue;\n\t\t\t\t\t} else if (typeof realValue === \"object\") {\n\t\t\t\t\t\tfor (const styleName in realValue) {\n\t\t\t\t\t\t\tnode.style[styleName] = realValue[styleName];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnode.removeAttribute(\"sx\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Check name for multiple applied startKeys and apply everyone of them in order.\n\t\t\t\t * {!?.} -> Expand Object into array, \n\t\t\t\t * \t\t\tconditional check, \n\t\t\t\t * \t\t\tapply as JS property.\n\t\t\t\t * \n\t\t\t\t * \tRegex -> {([@.?!]+)}\n\t\t\t\t */\n\n\t\t\t\tconst isMultiCharacterAttribute = name.match(MATCH_MULTI_CHAR);\n\n\t\t\t\tvar arrAttributes = [];\n\n\t\t\t\tconst _applyArray = (callback) => {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\tfor (const x of arrAttributes) {\n\t\t\t\t\t\tconst result = callback(x[0], x[1]);\n\t\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\t\tdelete arrAttributes[i];\n\t\t\t\t\t\t\tarrAttributes = arrAttributes.filter(y => y)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst _applyEvent = (useArr = false) => {\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply event listener (@@ makes sure only this node triggers the event)\n\t\t\t\t\t */\n\t\t\t\t\tif (useArr) {\n\t\t\t\t\t\t_applyArray((key, val) => {\n\t\t\t\t\t\t\tapplyEvent(node, key, val, false);\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar onlyThisNode = false;\n\t\t\t\t\t\tif (name[1] === \"@\") {\n\t\t\t\t\t\t\tonlyThisNode = true;\n\t\t\t\t\t\t\trealName = realName.substring(1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tapplyEvent(node, realName, realValue, onlyThisNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst _applyJS = (useArr = false) => {\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply property per JS\n\t\t\t\t\t */\n\t\t\t\t\tif (useArr) {\n\t\t\t\t\t\t_applyArray((key, val) => {\n\t\t\t\t\t\t\tnode[key] = val\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode[realName] = realValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst _applyConditional = (useArr = false) => {\n\t\t\t\t\t/**\n\t\t\t\t\t * Check truthyness, apply if true\n\t\t\t\t\t */\n\t\t\t\t\tif (useArr) {\n\t\t\t\t\t\t_applyArray((key, val) => {\n\t\t\t\t\t\t\tif (val instanceof _shared_internals_js__WEBPACK_IMPORTED_MODULE_1__.ValueBinder) {\n\t\t\t\t\t\t\t\tval = val.valueOf()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!val) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (realValue instanceof _shared_internals_js__WEBPACK_IMPORTED_MODULE_1__.ValueBinder) {\n\t\t\t\t\t\t\trealValue = realValue.valueOf()\n\t\t\t\t\t\t}\n\t\t\t\t\t\trealValue ? node[realName] = realValue : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst _applyObject = (useArr = false) => {\n\t\t\t\t\t/**\n\t\t\t\t\t * Arguments inside an object (e.g. for unexpected args)\n\t\t\t\t\t */\n\t\t\t\t\tfor (const i in realValue) {\n\t\t\t\t\t\tif (useArr) {\n\t\t\t\t\t\t\tarrAttributes.push([i, realValue[i]])\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode.setAttribute(i, realValue[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst applyFromChar = (char, arr = true) => {\n\t\t\t\t\tif (char === \"!\") {\n\t\t\t\t\t\t_applyObject(arr)\n\t\t\t\t\t} else if (char === \".\") {\n\t\t\t\t\t\t_applyJS(arr)\n\t\t\t\t\t} else if (char === \"?\") {\n\t\t\t\t\t\t_applyConditional(arr)\n\t\t\t\t\t} else if (char === \"@\") {\n\t\t\t\t\t\t_applyEvent(arr)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tapplyValue = realValue\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isMultiCharacterAttribute) {\n\t\t\t\t\tfor (const char of isMultiCharacterAttribute[1]) {\n\t\t\t\t\t\tapplyFromChar(char, true)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tapplyFromChar(nameStart, false)\n\t\t\t\t}\n\n\t\t\t\t_applyArray((key, val) => {\n\t\t\t\t\tnode.setAttribute(key, val)\n\t\t\t\t})\n\n\t\t\t\treturn applyValue;\n\t\t\t})\n\t\t\tif ([\"@\", \".\", \"?\", \"!\"].indexOf(nameStart) !== -1 || name.match(MATCH_MULTI_CHAR)) {\n\t\t\t\tnode.removeAttribute(name)\n\t\t\t} else if (name !== \"ref\") {\n\t\t\t\tnode.setAttribute(name, value)\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Check text nodes, append HTML if necessary\n\t\t */\n\t\tvar childNodes = Array.from(node.childNodes);\n\t\tfor (const children of childNodes) {\n\t\t\tif (children.nodeType === Node.TEXT_NODE) {\n\t\t\t\tvar innerText = children.wholeText;\n\t\t\t\tconst matchArray = Array.from(innerText.matchAll(MATCH_INDEX_REGEX));\n\t\t\t\tinnerText = innerText.replace(MATCH_INDEX_REGEX, (i) => {\n\t\t\t\t\treturn \" \".repeat(i.length)\n\t\t\t\t})\n\t\t\t\tif (matchArray.length > 0) {\n\t\t\t\t\t// We're gonna insert everything from scratch, just remove all content before inserting something twice...\n\t\t\t\t\tchildren.textContent = \"\"\n\t\t\t\t}\n\t\t\t\tvar lastOffsetIndex = 0;\n\t\t\t\tfor (let i = 0; i < matchArray.length; i++) {\n\t\t\t\t\tconst match = matchArray[i];\n\t\t\t\t\tvar index = parseInt(match[1]);\n\t\t\t\t\tvar value = vars[index];\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Insert text before the element if existed beforehand.\n\t\t\t\t\t */\n\t\t\t\t\tvar insertBefore = innerText.substring(lastOffsetIndex, match.index);\n\t\t\t\t\tif (insertBefore !== \"\") {\n\t\t\t\t\t\tinsertText(node, insertBefore)\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t * Object is no primitive, handle differently\n\t\t\t\t\t */\n\t\t\t\t\tconst appendNonPrimitive = (value) => {\n\t\t\t\t\t\tif (value instanceof HTMLElement || value instanceof SVGElement || value instanceof Text) {\n\t\t\t\t\t\t\tvalue.insertAfter(children)\n\t\t\t\t\t\t} else if (value instanceof HTMLCollection || value instanceof NodeList) {\n\t\t\t\t\t\t\tvar span = document.createElement(\"span\")\n\t\t\t\t\t\t\tspan.insertAfter(children)\n\t\t\t\t\t\t\tspan.replaceWith(...value)\n\t\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\t\tvalue.reverse().map(x => appendNonPrimitive(x))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (value !== Object(value) || value instanceof _shared_internals_js__WEBPACK_IMPORTED_MODULE_1__.ValueBinder) {\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * Handle primitive, simple insert\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tinsertText(node, value)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconsole.error('The value you passed as a variable is not yet supported.')\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tappendNonPrimitive(value)\n\n\t\t\t\t\tif (i == matchArray.length - 1) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Last element, append rest of string.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tchildren.remove()\n\t\t\t\t\t\tvar insertAfter = innerText.substring(match.index + match[0].length)\n\t\t\t\t\t\tif (insertAfter != \"\") {\n\t\t\t\t\t\t\tinsertText(node, insertAfter)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlastOffsetIndex = match.index + value && value.length\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Loop through all children again and render components\n\t */\n\tconst child = template.content.children[0];\n\t_snowblind_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].renderAllIn(child)\n\treturn child\n}\n\nfunction repeat(items, itemTemplate, keyFunction = () => {}) {\n\tvar arr = []\n\tfor (const i in items) {\n\t\tconst item = items[i];\n\t\tvar uniqueKey = keyFunction(i, item);\n\t\tarr.push(itemTemplate(i, item, uniqueKey));\n\t}\n\treturn arr\n}\n\nfunction classMap(classes) {\n\tvar classNames = []\n\tfor (const key in classes) {\n\t\tconst evaluationProperty = classes[key];\n\t\tif (evaluationProperty) {\n\t\t\tclassNames.push(key)\n\t\t}\n\t}\n\treturn classNames.join(\" \").trim();\n}\n\n/**\n * Takes an array of classes and returns them as string if they evaluate to true.\n * @param {Array} classes Array of classes to be checked\n * @returns {String}\n */\nfunction classArray(classes) {\n\treturn classMap(Object.fromEntries(classes.map(x => {\n\t\tif (Array.isArray(x)) {\n\t\t\treturn Array.isArray(x[0]) ? x[0].map(y => [y, x[1]]) : x;\n\t\t} else {\n\t\t\treturn [x, x ? true : false]\n\t\t}\n\t})))\n}\n\nfunction styleMap(styles) {\n\tvar string = \"\";\n\tfor (const i in styles) {\n\t\tstring += styles[i] ? `${i}: ${styles[i]};` : \"\";\n\t}\n\treturn string;\n}\n\nfunction when(condition, evaluateTrue, evaluateFalse) {\n\treturn condition ? evaluateTrue() : evaluateFalse();\n}\n\nfunction choose(prop, options, fallback) {\n\tif (options.hasOwnProperty(prop)) {\n\t\treturn options[prop](prop);\n\t}\n\treturn fallback()\n}\n\nfunction range(start, end, step = 1) {\n\treturn Array((end - start) / step).fill(0).map((x, i) => i * step + start)\n}\n\n/**\n * Takes a condition and element only returns it if the condition is true.\n * @param {any} condition The condition to be checked\n * @param {any} element The return value if the condition is true\n * @returns {any | String}\n */\nfunction elemIf(condition, element) {\n\treturn condition ? element : \"\";\n}\n/**\n * Inserts a given element after another.\n * @param {HTMLElement} el The element given node should be inserted after.\n */\nHTMLElement.prototype.insertAfter = function (el) {\n\tif (el && el.parentNode) {\n\t\tel.parentNode.insertBefore(this, el.nextSibling);\n\t}\n};\n\n\n\n//# sourceURL=webpack://@snowblind/core/./src/html.js?");

/***/ }),

/***/ "./src/observer.js":
/*!*************************!*\
  !*** ./src/observer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Observer\": () => (/* binding */ Observer)\n/* harmony export */ });\nconst isProxy = Symbol(\"\");\n\nclass Observer {\n\t/**\n\t * Instantiates a proxy based on a passed object supporting rerendering of components.\n\t * @param {object} value The object a proxy should be attached to.\n\t */\n\tconstructor(value) {\n\t\tthis.boundRender = false;\n\t\tconst _Handler = {\n\t\t\tget(target, key) {\n\t\t\t\tif (key === isProxy) return true;\n\n\t\t\t\tconst prop = target[key];\n\t\t\t\tif (typeof prop == 'undefined') {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// set value as proxy if object\n\t\t\t\tif (prop !== null) {\n\t\t\t\t\tvar constructor = prop.constructor;\n\t\t\t\t\tif (!prop[isProxy] && constructor && ((constructor === ({}).constructor) || (constructor === ([]).constructor))) {\n\t\t\t\t\t\ttarget[key] = new Proxy(prop, _Handler);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn target[key];\n\t\t\t},\n\t\t\tset: (x, y, z) => {\n\t\t\t\tx[y] = z;\n\t\t\t\tif (this.boundRender) {\n\t\t\t\t\tif (this.debounce) {\n\t\t\t\t\t\twindow.cancelAnimationFrame(this.debounce);\n\t\t\t\t\t}\n\t\t\t\t\tthis.debounce = window.requestAnimationFrame(() => {\n\t\t\t\t\t\tthis.boundRender.Render()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tthis._value = new Proxy(value, _Handler);\n\t}\n}\n\n\n\n//# sourceURL=webpack://@snowblind/core/./src/observer.js?");

/***/ }),

/***/ "./src/render-assignment.js":
/*!**********************************!*\
  !*** ./src/render-assignment.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RenderAssignment)\n/* harmony export */ });\n/* harmony import */ var _snowblind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./snowblind.js */ \"./src/snowblind.js\");\n\n\nclass RenderAssignment {\n\tconstructor(obj, options = {}) {\n\t\tobj._Observer.boundRender = this\n\t\tthis._wasDestroyed = false;\n\t\tthis._renderIsFirstTime = true\n\t\tthis._maxCopies = obj._maxCopies;\n\t\tthis._copiesKeptAlive = 0;\n\t\tthis._lastNode = options.replace || document.body.appendChild(document.createElement(\"i\"));\n\t\tthis._Node;\n\t\tthis.Object = obj\n\t\tif (!(obj instanceof _snowblind_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Component)) {\n\t\t\tthrow new Error(\"Renderer didn't receive object of type Snowblind.Component\");\n\t\t}\n\t}\n\n\tRender() {\n\t\tif (this._wasDestroyed) {\n\t\t\t/**\n\t\t\t * Destroy method has been called, cancel the render\n\t\t\t */\n\t\t\tthrow new Error(\"Renderer has been destroyed.\")\n\t\t}\n\n\t\tif (this.Object._usesTransition) {\n\t\t\tconst currentNode = this._Node;\n\t\t\tif (this._copiesKeptAlive >= this._maxCopies) {\n\t\t\t\tcurrentNode.remove()\n\t\t\t} else {\n\t\t\t\tthis.Object.transitionFunction.leave(() => {\n\t\t\t\t\tcurrentNode.remove()\n\t\t\t\t\tthis._copiesKeptAlive -= 1\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Give access to parent element\n\t\t */\n\t\tthis.Object.parentElement = this._lastNode.parentNode;\n\t\tvar obj = this.Object.render()\n\t\tif (obj instanceof HTMLElement) {\n\t\t\t/**\n\t\t\t * Keep eventListeners and append directly as HTMLElement\n\t\t\t */\n\t\t\tthis._Node = obj\n\t\t} else {\n\t\t\tthrow new Error(\"Can only initialize object with type of HTMLElement.\")\n\t\t}\n\t\t/**\n\t\t * Reset nodes on base object\n\t\t */\n\t\tthis.Object.Node = this._Node\n\t\tvar Node = this._Node\n\t\tconst activeElement = document.activeElement;\n\t\tconst selectionStart = activeElement.selectionStart;\n\t\tconst selectionEnd = activeElement.selectionEnd;\n\t\tthis._lastNode.parentNode.replaceChild(Node, this._lastNode);\n\t\tif (activeElement) {\n\t\t\t// Check if there was a focused element and if it had a `key` attribute that might be used to re-focus it.\n\t\t\tconst key = activeElement.getAttribute(\"key\");\n\t\t\tif (key) {\n\t\t\t\t// Key found, let's focus the element.\n\t\t\t\tconst focusNode = Node.querySelector(`[key='${key}']`)\n\t\t\t\tfocusNode.focus();\n\t\t\t\tfocusNode.setSelectionRange(selectionStart, selectionEnd)\n\t\t\t}\n\t\t}\n\t\tthis._lastNode = Node;\n\t\t/**\n\t\t * Provide node to the component\n\t\t */\n\n\t\tif (this.Object._usesTransition) {\n\t\t\t/**\n\t\t\t * Apply any transition effects to the node\n\t\t\t */\n\t\t\tthis._copiesKeptAlive++\n\t\t\tthis.Object.transitionFunction.from(() => {\n\t\t\t\tif (!this._renderIsFirstTime) {\n\t\t\t\t\tthis.Object.transitionFunction.render()\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\n\n\t\tif (this.Object.hasTheme) {\n\t\t\t/**\n\t\t\t * Apply custom styling\n\t\t\t */\n\t\t\tconst compareStyles = document.createElement(\"div\");\n\t\t\tconst appendStyles = (elements, query) => {\n\t\t\t\tconst properties = this.Object.hasTheme[query];\n\t\t\t\tfor (const subNode of Array.from(elements)) {\n\t\t\t\t\tif (typeof properties === \"object\") {\n\t\t\t\t\t\tfor (const propName in properties) {\n\t\t\t\t\t\t\tsubNode.style[propName] = properties[propName]\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubNode.style[query] = properties\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const query in this.Object.hasTheme) {\n\t\t\t\tconst elements = Node.querySelectorAll(query)\n\t\t\t\tif (elements && elements.length > 0) {\n\t\t\t\t\tappendStyles(elements, query)\n\t\t\t\t} else if (typeof compareStyles.style[query] !== \"undefined\") {\n\t\t\t\t\tappendStyles(Array.from(Node.getElementsByTagName(\"*\")).concat([Node]), query)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._renderIsFirstTime === true) {\n\t\t\t/**\n\t\t\t * Component is only mounted AFTER the render finishes\n\t\t\t */\n\t\t\texecArray(this.Object.didMountCallbacks)\n\t\t\tthis._renderIsFirstTime = false\n\t\t} else {\n\t\t\t/**\n\t\t\t * Run componentDidUpdate() method AFTER component rerender\n\t\t\t */\n\t\t\texecArray(this.Object.didUpdateCallbacks)\n\t\t}\n\t}\n\n\treinitialize() {\n\t\t/**\n\t\t * Build the render again (reset render status and call constructor)\n\t\t */\n\t\tthis._renderIsFirstTime = true\n\t\tthis.constructor(this.Object)\n\t}\n\n\tDestroy() {\n\t\t/**\n\t\t * Unmount component then remove node and linking element\n\t\t */\n\t\tthis._wasDestroyed = true\n\t\texecArray(this.Object.willUnmountCallbacks)\n\t\tif (this.Object._usesTransition) {\n\t\t\tthis.Object.transitionFunction.leave(() => {\n\t\t\t\tthis._Node.remove()\n\t\t\t})\n\t\t} else {\n\t\t\tthis._Node.remove()\n\t\t}\n\t}\n}\n\nconst execArray = (arr) => arr.map(x => x());\n\n//# sourceURL=webpack://@snowblind/core/./src/render-assignment.js?");

/***/ }),

/***/ "./src/shared-internals.js":
/*!*********************************!*\
  !*** ./src/shared-internals.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Observable\": () => (/* binding */ Observable),\n/* harmony export */   \"UpdateDispatcher\": () => (/* binding */ UpdateDispatcher),\n/* harmony export */   \"ValueBinder\": () => (/* binding */ ValueBinder),\n/* harmony export */   \"exposedComponents\": () => (/* binding */ exposedComponents)\n/* harmony export */ });\nclass Observable {\n\tconstructor(value) {\n\t\tthis._value = value;\n\t\tthis._subscribers = [];\n\t}\n\n\tnext(value) {\n\t\tthis._value = value;\n\t\tfor (const subscriber of this._subscribers) {\n\t\t\tsubscriber(value)\n\t\t}\n\t}\n\n\tsubscribe(callback) {\n\t\tthis._subscribers.push(callback);\n\t}\n\n\tcomplete() {\n\t\tthis._subscribers = new Proxy([], {set: () => {\n\t\t\tthrow new Error(\"Observable has been completed.\")\n\t\t}});\n\t}\n\n\trestore() {\n\t\tthis._subscribers = [];\n\t\tthis._value = undefined;\n\t}\n}\n\nclass ValueBinder {\n\tconstructor(obs) {\n\t\tthis.observable = obs;\n\t\tthis.value = obs._value;\n\n\t\tobs.subscribe((val) => {\n\t\t\tthis.value = val\n\t\t})\n\t}\n\n\tvalueOf() {\n\t\treturn this.value\n\t}\n\n\ttoString() {\n\t\treturn this.value.toString()\n\t}\n};\n\n\nconst exposedComponents = {};\nconst UpdateDispatcher = new Observable();\n\n\n\n//# sourceURL=webpack://@snowblind/core/./src/shared-internals.js?");

/***/ }),

/***/ "./src/snowblind.js":
/*!**************************!*\
  !*** ./src/snowblind.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"useEffect\": () => (/* reexport safe */ _modules_hooks_index_js__WEBPACK_IMPORTED_MODULE_4__.useEffect),\n/* harmony export */   \"useRef\": () => (/* reexport safe */ _modules_hooks_index_js__WEBPACK_IMPORTED_MODULE_4__.useRef),\n/* harmony export */   \"useState\": () => (/* reexport safe */ _modules_hooks_index_js__WEBPACK_IMPORTED_MODULE_4__.useState),\n/* harmony export */   \"useTransition\": () => (/* reexport safe */ _modules_hooks_index_js__WEBPACK_IMPORTED_MODULE_4__.useTransition)\n/* harmony export */ });\n/* harmony import */ var _render_assignment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render-assignment.js */ \"./src/render-assignment.js\");\n/* harmony import */ var _observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observer.js */ \"./src/observer.js\");\n/* harmony import */ var _modules_typecheck_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/typecheck.js */ \"./modules/typecheck.js\");\n/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./html.js */ \"./src/html.js\");\n/* harmony import */ var _modules_hooks_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../modules/hooks/index.js */ \"./modules/hooks/index.js\");\n/* harmony import */ var _shared_internals_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shared-internals.js */ \"./src/shared-internals.js\");\n\n\n\n\n\n\n\n\n\n/**\n * Exposes a component to be grabbed by the initial render process.\n * @param {Array<Snowblind.Component>} components List of components to add\n * @param {Array<String>} optNames Optional list of names if they shall not be auto-retrieved from the components class name.\n */\nwindow.expose = function (components, optNames) {\n\tcomponents = Array.from([components]).flat();\n\toptNames = Array.from([optNames]).flat()\n\n\tfor (let i = 0; i < components.length; i++) {\n\t\tconst component = components[i];\n\t\tvar name = (typeof optNames[i] === \"undefined\" ? component.name : optNames[i]).toLowerCase();\n\t\t_shared_internals_js__WEBPACK_IMPORTED_MODULE_5__.exposedComponents[name] = component;\n\t}\n}\n\n/**\n * Add component to global scope;\n */\nconst Snowblind = {\n\tComponent: class Component {\n\t\tconstructor(props, generator, options = {}) {\n\t\t\toptions = Object.assign({\n\t\t\t\treplace: false,\n\t\t\t\thasTheme: false,\n\t\t\t}, options)\n\n\t\t\tthis.createdReferences = {} // All references to nodes created with (useRef())\n\t\t\tthis.globalSelf = _shared_internals_js__WEBPACK_IMPORTED_MODULE_5__.exposedComponents[this.constructor.name.toLowerCase()];\n\t\t\t/**\n\t\t\t * Convert expected properties\n\t\t\t */\n\t\t\tif (this.globalSelf) {\n\t\t\t\tconst propTypes = this.globalSelf.propTypes;\n\t\t\t\tif (propTypes) {\n\t\t\t\t\tprops = (0,_modules_typecheck_js__WEBPACK_IMPORTED_MODULE_2__.typeCheck)(props, propTypes, this.globalSelf.defaultProps)\n\t\t\t\t\tthis.unexpectedArguments = {}\n\t\t\t\t\tfor (const typeName in props) {\n\t\t\t\t\t\tvar value = props[typeName];\n\t\t\t\t\t\tif (!propTypes.hasOwnProperty(typeName)) {\n\t\t\t\t\t\t\tthis.unexpectedArguments[typeName] = value;\n\t\t\t\t\t\t\tdelete props[typeName];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Custom theme when object created from styled() function\n\t\t\t */\n\t\t\tthis.hasTheme = options.hasTheme;\n\t\t\tthis._watchingObservers = []\n\t\t\tthis._maxCopies = Infinity;\n\t\t\t/**\n\t\t\t * Check if obj is a function, then it needs execution\n\t\t\t */\n\t\t\tthis._usesTransition = false\n\n\t\t\t/**\n\t\t\t * Setup arrays for event listening\n\t\t\t */\n\t\t\tthis.didMountCallbacks = []\n\t\t\tthis.didUpdateCallbacks = []\n\t\t\tthis.willUnmountCallbacks = []\n\t\t\t/**\n\t\t\t * Initialize empty dependencies object for useEffect calls\n\t\t\t */\n\t\t\tif (options.replace instanceof HTMLElement) {\n\t\t\t\tprops.children = Array.from(options.replace.childNodes);\n\t\t\t\tthis.originalElement = options.replace\n\t\t\t\tthis.originalChildren = Array.from(options.replace.childNodes);\n\t\t\t}\n\t\t\tthis._Observer = new _observer_js__WEBPACK_IMPORTED_MODULE_1__.Observer(props || {})\n\t\t\tthis.props = this._Observer._value\n\n\t\t\tthis.Renderer = new _render_assignment_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this, options)\n\t\t\tthis._generatorFunction = generator(props)\n\t\t\t/**\n\t\t\t * Write component to the UpdateDispatcher to be captured by any hooks, close immediately after.\n\t\t\t */\n\t\t\t_shared_internals_js__WEBPACK_IMPORTED_MODULE_5__.UpdateDispatcher.next(this);\n\t\t\t_shared_internals_js__WEBPACK_IMPORTED_MODULE_5__.UpdateDispatcher.restore();\n\t\t\t\n\t\t\tfor (const i of this._watchingObservers) {\n\t\t\t\ti.boundRender = this.Renderer\n\t\t\t}\n\t\t\tthis.Renderer.Render()\n\t\t}\n\n\t\tonComponentDidMount(callback) {\n\t\t\tthis.didMountCallbacks.push(callback)\n\t\t}\n\n\t\tonComponentDidUpdate(callback) {\n\t\t\tthis.didUpdateCallbacks.push(callback)\n\t\t}\n\t\tonComponentWillUnmount() {\n\t\t\tthis.willUnmountCallbacks.push(callback)\n\t\t}\n\n\t\trender(...args) {\n\t\t\treturn this._generatorFunction()\n\t\t}\n\t},\n\t/**\n\t * Searches the DOMTree recursively for components, this will ensure parent nodes will be rendered and their children will be included in the render afterwards\n\t */\n\trenderAllIn(element = document.body) {\n\t\tconst recurse = (parentList) => {\n\t\t\t// Filter out scripts\n\t\t\tfor (const parent of parentList) {\n\t\t\t\tif (parent instanceof HTMLScriptElement) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet nodeName = parent.nodeName.toLowerCase()\n\t\t\t\tif (_shared_internals_js__WEBPACK_IMPORTED_MODULE_5__.exposedComponents.hasOwnProperty(nodeName)) {\n\t\t\t\t\t// Element nodeName in the names of exposed components, it must be one!\n\t\t\t\t\tlet component = _shared_internals_js__WEBPACK_IMPORTED_MODULE_5__.exposedComponents[nodeName];\n\t\t\t\t\tlet isFunction = typeof component === 'function'\n\t\t\t\t\tif (isFunction) {\n\t\t\t\t\t\tconst props = this.getNodeProperties(parent);\n\t\t\t\t\t\tnew Snowblind.Component(props, component, {\n\t\t\t\t\t\t\treplace: parent\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// No component here! Let's go deeper!\n\t\t\t\t\trecurse(Array.from(parent.children))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trecurse(Array.from(element.children));\n\t},\n\tgetNodeProperties(node) {\n\t\treturn Object.fromEntries(Array.from(node.attributes).map(x => {\n\t\t\tvar attributeValue = x.value,\n\t\t\t\tattributeName = x.name;\n\t\t\tlet Value;\n\t\t\tif ((Value = attributeValue.match(/\\{\\{([A-z0-9_ ]*?)\\}\\}/))) {\n\t\t\t\t/**\n\t\t\t\t * Try to assign a constant when finding this: \"{{constantName}}\"\n\t\t\t\t */\n\t\t\t\tvar constantName = Value[1].trim(),\n\t\t\t\t\ttype = typeof window[constantName]\n\t\t\t\tif (type !== \"undefined\" && type !== \"function\") {\n\t\t\t\t\tattributeValue = window[constantName]\n\t\t\t\t} else if (type === \"function\") {\n\t\t\t\t\tattributeValue = constantName + constantName.endsWith(\"()\") ? \"\" : \"()\"\n\t\t\t\t}\n\t\t\t} else if (attributeName.startsWith(\":\")) {\n\t\t\t\t/**\n\t\t\t\t * User passed HTML as attribute, convert to node\n\t\t\t\t */\n\t\t\t\tvar attributeValue = (0,_html_js__WEBPACK_IMPORTED_MODULE_3__.html)([attributeValue]);\n\t\t\t\tattributeName = attributeName.substring(1)\n\t\t\t} else if (attributeValue.startsWith(\"{\") && attributeValue.endsWith(\"}\")) {\n\t\t\t\tvar innerValue = attributeValue.substring(1, attributeValue.length - 1)\n\t\t\t\tif (innerValue === \"true\" || innerValue === \"false\") {\n\t\t\t\t\t/**\n\t\t\t\t\t * Try to match the value to a typical datatype\n\t\t\t\t\t */\n\t\t\t\t\tattributeValue = innerValue === \"true\" ? true : false;\n\t\t\t\t} else if (parseFloat(innerValue) == innerValue) {\n\t\t\t\t\tattributeValue = parseFloat(innerValue)\n\t\t\t\t}\n\t\t\t} else if (attributeValue.startsWith(\"[\") && attributeValue.endsWith(\"]\")) {\n\t\t\t\t/**\n\t\t\t\t * Make an array\n\t\t\t\t */\n\t\t\t\tattributeValue = JSON.parse(attributeValue.replace(/(?<!\\\\)'/g, '\"'));\n\t\t\t}\n\t\t\t/**\n\t\t\t * style can not be used, circumvent by adding _ in front, has to be removed here\n\t\t\t */\n\t\t\treturn [attributeName.startsWith(\"_\") ? attributeName.substring(1) : attributeName, attributeValue]\n\t\t}))\n\t},\n\teventBus: {\n\t\ton(event, callback) {\n\t\t\tdocument.addEventListener(event, (e) => callback(e.detail));\n\t\t},\n\t\tdispatch(event, data) {\n\t\t\tdocument.dispatchEvent(new CustomEvent(event, {\n\t\t\t\tdetail: data\n\t\t\t}));\n\t\t},\n\t\tremove(event, callback) {\n\t\t\tdocument.removeEventListener(event, callback);\n\t\t},\n\t},\n\tcreateElement: (type, props, children = []) => {\n\t\tlet element = document.createElement(type);\n\t\tfor (let name in props) {\n\t\t\tif (Object.hasOwnProperty.call(props, name)) {\n\t\t\t\tlet value = props[name];\n\t\t\t\tif (value !== null && value !== undefined) {\n\t\t\t\t\tif (name == \"text\") {\n\t\t\t\t\t\telement.innerText = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet trimmedName = name.substring(1).replace(\"@\", \"\");\n\t\t\t\t\t\tif (name[0] === \"@\") {\n\t\t\t\t\t\t\telement.addEventListener(name, (e) => {\n\t\t\t\t\t\t\t\tif (name[1] == \"@\" && e.target.isEqualNode(element)) {\n\t\t\t\t\t\t\t\t\tvalue(element, e)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvalue(element, e)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t} else if (name[0] === \".\") {\n\t\t\t\t\t\t\telement[trimmedName] = value;\n\t\t\t\t\t\t} else if (name[0] === \"?\") {\n\t\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\t\telement.setAttribute(trimmedName, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (typeof value === \"object\") {\n\t\t\t\t\t\t\tfor (const i in value) {\n\t\t\t\t\t\t\t\telement.setAttribute(i, value[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telement.setAttribute(name, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let node of children) {\n\t\t\tif (typeof node === \"function\") {\n\t\t\t\t// Check if a component reference was passed.\n\t\t\t\t\n\t\t\t} else if (node instanceof HTMLElement) {\n\t\t\t\telement.appendChild(node);\n\t\t\t}\n\t\t}\n\t\treturn element;\n\t}\n}\n\nwindow.addEventListener(\"load\", () => {\n\tSnowblind.renderAllIn()\n})\n\n/**\n * Inserts a given element after another.\n * @param {HTMLElement} el The element given node should be inserted after.\n */\nHTMLElement.prototype.insertAfter = function (el) {\n\tif (el && el.parentNode) {\n\t\tel.parentNode.insertBefore(this, el.nextSibling);\n\t}\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Snowblind);\n\n//# sourceURL=webpack://@snowblind/core/./src/snowblind.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./index.js");
/******/ var __webpack_exports__default = __webpack_exports__["default"];
/******/ export { __webpack_exports__default as default };
/******/ 
