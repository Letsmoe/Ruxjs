/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _src_snowblind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/snowblind.js */ \"./src/snowblind.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_src_snowblind_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://snowblind/./index.js?");

/***/ }),

/***/ "./modules/typecheck.js":
/*!******************************!*\
  !*** ./modules/typecheck.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"propTypes\": () => (/* binding */ propTypes),\n/* harmony export */   \"typeCheck\": () => (/* binding */ typeCheck),\n/* harmony export */   \"typeIf\": () => (/* binding */ typeIf)\n/* harmony export */ });\nconst propTypes = new Proxy({\n\tNumber: (x) => typeof x === 'number',\n\tInteger: (x) => (typeof x === 'number') && x % 1 === 0,\n\tBigInt: (x) => typeof x === \"bigint\",\n\tFloat: (x) => (typeof x === \"number\") && x % 1 !== 0,\n\tString: (x) => typeof x === \"string\",\n\tArray: (x) => Array.isArray(x),\n\tObject: (x) => (typeof x === \"object\") && !Array.isArray(x),\n\tSymbol: (x) => typeof x === \"symbol\",\n\tBoolean: (x) => typeof x === \"boolean\",\n\tFunction: (x) => typeof x === \"function\",\n\tnode: (x) => [\"number\", \"string\"].indexOf(typeof x) > -1 || x instanceof HTMLElement || Array.isArray(x),\n\telement: (x) => x instanceof HTMLElement,\n\telementType: (x) => x instanceof undefined.Component,\n\tinstanceOf: function (instance) {\n\t\treturn (x) => x instanceof instance;\n\t},\n\ttypeOf: function (type) {\n\t\treturn (x) => typeof x === type;\n\t},\n\toneOfType: function (types) {\n\t\treturn (x) => {\n\t\t\treturn types.map(y => {\n\t\t\t\treturn typeof y === \"function\" ? y(x) : this[y](x)\n\t\t\t}).indexOf(true) > -1\n\t\t};\n\t},\n\toneOf: function (values) {\n\t\treturn (x) => {\n\t\t\treturn values.indexOf(x) > -1;\n\t\t}\n\t},\n\tarrayOf: function (type) {\n\t\treturn (x) => {\n\t\t\treturn this.Array.isArray(x) ? x.map(y => {\n\t\t\t\ttypeof type === \"function\" ? type(x) : this[type](x)\n\t\t\t}).indexOf(false) === -1 : false\n\t\t};\n\t},\n\tobjectOf: function (type) {\n\t\treturn (x) => {\n\t\t\treturn x ? this.arrayOf(type)(Object.values(x)) : false\n\t\t};\n\t},\n\tshape: function (typeObject) {\n\t\treturn (testObj) => {\n\t\t\t/**\n\t\t\t * Run exact inexactly :)\n\t\t\t */\n\t\t\treturn this.exact(typeObject, true)(testObj)\n\t\t}\n\t},\n\texact: function (typeObject, runInexact = false) {\n\t\treturn (testObj) => {\n\t\t\tif (testObj && typeObject) {\n\t\t\t\tfor (const i in testObj) {\n\t\t\t\t\tif (typeObject.hasOwnProperty(i)) {\n\t\t\t\t\t\tvar compareFunc = typeof typeObject[i] === \"string\" ? this[typeObject[i]] : typeObject[i];\n\t\t\t\t\t\tvar result = compareFunc(testObj[i])\n\t\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\t\treturn result\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!runInexact) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t},\n\tcustomProp: (Func) => {\n\t\treturn Func\n\t},\n\tAny: () => true\n}, {\n\tset: () => false,\n\tget: function (obj, key) {\n\t\tif (obj.hasOwnProperty(key)) {\n\t\t\tvar Func = obj[key];\n\t\t\tFunc.isRequired = function (x, prop) {\n\t\t\t\tif (typeof x === \"undefined\") {\n\t\t\t\t\tthrow new Error(`Encountered undefined prop \"${prop}\" as required object.`)\n\t\t\t\t} else {\n\t\t\t\t\treturn obj[key](x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tFunc.ofLength = function (length) {\n\t\t\t\treturn (x) => {\n\t\t\t\t\treturn obj[key](x) && x.length === length;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Func\n\t\t} else {\n\t\t\tthrow new Error(`Invalid type for property \"${key}\" encountered.`)\n\t\t}\n\t}\n})\n\nconst typeIf = function (value, type, ifTrue, ifFalse) {\n\tvar result = typeCheck({\n\t\tvalue: value\n\t}, {\n\t\tvalue: type\n\t}, {}, {\n\t\treturnBool: true\n\t})\n\treturn result ? ifTrue : ifFalse;\n}\n\nconst typeCheck = function (obj, optPropertyTypes, defaultProps, options) {\n\toptions = Object.assign({\n\t\treturnBool: false\n\t}, options)\n\tobj = Object.assign({}, defaultProps, obj)\n\tvar store = []\n\tif (typeof optPropertyTypes !== 'undefined') {\n\t\tfor (const prop in optPropertyTypes) {\n\t\t\tconst propType = optPropertyTypes[prop];\n\t\t\tconst runFunction = typeof propType === \"function\" ? propType : (propTypes[propType] || (() => false))\n\t\t\tvar Result = runFunction(obj[prop], prop);\n\t\t\tif (Result === false) {\n\t\t\t\tif (options.returnBool) {\n\t\t\t\t\treturn Result;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`Invalid type for property \"${prop}\" encountered.`)\n\t\t\t\t}\n\t\t\t}\n\t\t\tstore.push(Result)\n\t\t}\n\t}\n\tif (options.returnBool && store.indexOf(false) === -1) {\n\t\treturn true\n\t}\n\treturn obj\n}\n\n\n\n//# sourceURL=webpack://snowblind/./modules/typecheck.js?");

/***/ }),

/***/ "./src/html.js":
/*!*********************!*\
  !*** ./src/html.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"choose\": () => (/* binding */ choose),\n/* harmony export */   \"classArray\": () => (/* binding */ classArray),\n/* harmony export */   \"classMap\": () => (/* binding */ classMap),\n/* harmony export */   \"html\": () => (/* binding */ html),\n/* harmony export */   \"range\": () => (/* binding */ range),\n/* harmony export */   \"repeat\": () => (/* binding */ repeat),\n/* harmony export */   \"styleMap\": () => (/* binding */ styleMap),\n/* harmony export */   \"when\": () => (/* binding */ when)\n/* harmony export */ });\n/* harmony import */ var _snowblind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./snowblind.js */ \"./src/snowblind.js\");\n/* harmony import */ var _shared_internals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared-internals.js */ \"./src/shared-internals.js\");\n\n\n\nfunction html(strings, ...vars) {\n\n\tfunction applyEvent(elem, trigger, event, onlyThisNode) {\n\t\telem.addEventListener(trigger, (e) => {\n\t\t\tif (onlyThisNode && e.target.isEqualNode(elem)) {\n\t\t\t\tevent(elem, e)\n\t\t\t} else if (!onlyThisNode) {\n\t\t\t\tevent(elem, e)\n\t\t\t}\n\t\t})\n\t}\n\n\tfunction insertText(elem, text) {\n\t\tvar textElement = document.createTextNode(text);\n\t\telem.appendChild(textElement);\n\t}\n\n\tfunction hasParent(element, tagName) {\n\t\tif (!element.parentNode) return false;\n\t\tif (element.tagName === tagName) return true;\n\t\treturn hasParent(element.parentNode, tagName);\n\t}\n\n\tconst MATCH_INDEX_REGEX = /\\{\\{([0-9]+)\\}\\}/g;\n\tvar result = \"\",\n\t\ti = 0;\n\tfor (const str of strings) {\n\t\tresult += str + (strings[strings.length - 1] === str ? \"\" : `{{${i++}}}`);\n\t}\n\tconst template = document.createElement(\"template\");\n\ttemplate.innerHTML = result;\n\n\t/**\n\t * Limit to one element per fragment, require multiple to be wrapped in another element.\n\t */\n\tif (template.content.children.length > 1) {\n\t\tthrow new Error(\"Multiple elements must be wrapped in a single element.\");\n\t}\n\n\tconst walker = document.createTreeWalker(template.content, 1, null);\n\n\tlet node;\n\tlet foundInputs = 0;\n\n\twhile ((node = walker.nextNode()) !== null) {\n\t\t/**\n\t\t * Check if node is an input or a textarea, if so, set a key for focusing it later on.\n\t\t */\n\t\tif (node instanceof HTMLTextAreaElement || node instanceof HTMLInputElement) {\n\t\t\tif (!node.hasAttribute(\"key\")) {\n\t\t\t\tnode.setAttribute(\"key\", \"inputNo\" + foundInputs);\n\t\t\t\tfoundInputs++\n\t\t\t}\n\t\t}\n\n\t\tfor (const attribute of Array.from(node.attributes)) {\n\t\t\tvar name = attribute.name;\n\t\t\tvar value = attribute.nodeValue;\n\t\t\tvar nameStart = name[0];\n\t\t\tvar realName = name.substring(1)\n\n\t\t\tconst MATCH_MULTI_CHAR = /\\{([@.?!]+)\\}/;\n\n\t\t\tvalue = value.replace(MATCH_INDEX_REGEX, (x, y) => {\n\t\t\t\tvar index = parseInt(y);\n\t\t\t\tvar realValue = vars[index];\n\t\t\t\tvar applyValue = \"\";\n\n\t\t\t\tif (name === \"ref\" && realValue.constructor && realValue.constructor.name === \"SnowblindRef\") {\n\t\t\t\t\t/**\n\t\t\t\t\t * User wants a reference to the current object\n\t\t\t\t\t */\n\t\t\t\t\trealValue.current = node;\n\t\t\t\t\tnode.isReferenceTo = realValue;\n\t\t\t\t\tnode.removeAttribute(\"ref\");\n\t\t\t\t\treturn\n\t\t\t\t} else if (name === \"sx\") {\n\t\t\t\t\t/**\n\t\t\t\t\t * Default style override\n\t\t\t\t\t */\n\t\t\t\t\tif (typeof realValue === \"string\") {\n\t\t\t\t\t\tnode.style = realValue;\n\t\t\t\t\t} else if (typeof realValue === \"object\") {\n\t\t\t\t\t\tfor (const styleName in realValue) {\n\t\t\t\t\t\t\tnode.style[styleName] = realValue[styleName];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnode.removeAttribute(\"sx\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Check name for multiple applied startKeys and apply everyone of them in order.\n\t\t\t\t * {!?.} -> Expand Object into array, \n\t\t\t\t * \t\t\tconditional check, \n\t\t\t\t * \t\t\tapply as JS property.\n\t\t\t\t * \n\t\t\t\t * \tRegex -> {([@.?!]+)}\n\t\t\t\t */\n\n\t\t\t\tconst isMultiCharacterAttribute = name.match(MATCH_MULTI_CHAR);\n\n\t\t\t\tvar arrAttributes = [];\n\n\t\t\t\tconst _applyArray = (callback) => {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\tfor (const x of arrAttributes) {\n\t\t\t\t\t\tconst result = callback(x[0], x[1]);\n\t\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\t\tdelete arrAttributes[i];\n\t\t\t\t\t\t\tarrAttributes = arrAttributes.filter(y => y)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst _applyEvent = (useArr = false) => {\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply event listener (@@ makes sure only this node triggers the event)\n\t\t\t\t\t */\n\t\t\t\t\tif (useArr) {\n\t\t\t\t\t\t_applyArray((key, val) => {\n\t\t\t\t\t\t\tapplyEvent(node, key, val, false);\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar onlyThisNode = false;\n\t\t\t\t\t\tif (name[1] === \"@\") {\n\t\t\t\t\t\t\tonlyThisNode = true;\n\t\t\t\t\t\t\trealName = realName.substring(1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tapplyEvent(node, realName, realValue, onlyThisNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst _applyJS = (useArr = false) => {\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply property per JS\n\t\t\t\t\t */\n\t\t\t\t\tif (useArr) {\n\t\t\t\t\t\t_applyArray((key, val) => {\n\t\t\t\t\t\t\tnode[key] = val\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode[realName] = realValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst _applyConditional = (useArr = false) => {\n\t\t\t\t\t/**\n\t\t\t\t\t * Check truthyness, apply if true\n\t\t\t\t\t */\n\t\t\t\t\tif (useArr) {\n\t\t\t\t\t\t_applyArray((key, val) => {\n\t\t\t\t\t\t\tif (val instanceof _shared_internals_js__WEBPACK_IMPORTED_MODULE_1__.ValueBinder) {\n\t\t\t\t\t\t\t\tval = val.valueOf()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!val) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (realValue instanceof _shared_internals_js__WEBPACK_IMPORTED_MODULE_1__.ValueBinder) {\n\t\t\t\t\t\t\trealValue = realValue.valueOf()\n\t\t\t\t\t\t}\n\t\t\t\t\t\trealValue ? node[realName] = realValue : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst _applyObject = (useArr = false) => {\n\t\t\t\t\t/**\n\t\t\t\t\t * Arguments inside an object (e.g. for unexpected args)\n\t\t\t\t\t */\n\t\t\t\t\tfor (const i in realValue) {\n\t\t\t\t\t\tif (useArr) {\n\t\t\t\t\t\t\tarrAttributes.push([i, realValue[i]])\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode.setAttribute(i, realValue[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst applyFromChar = (char, arr = true) => {\n\t\t\t\t\tif (char === \"!\") {\n\t\t\t\t\t\t_applyObject(arr)\n\t\t\t\t\t} else if (char === \".\") {\n\t\t\t\t\t\t_applyJS(arr)\n\t\t\t\t\t} else if (char === \"?\") {\n\t\t\t\t\t\t_applyConditional(arr)\n\t\t\t\t\t} else if (char === \"@\") {\n\t\t\t\t\t\t_applyEvent(arr)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tapplyValue = realValue\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isMultiCharacterAttribute) {\n\t\t\t\t\tfor (const char of isMultiCharacterAttribute[1]) {\n\t\t\t\t\t\tapplyFromChar(char, true)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tapplyFromChar(nameStart, false)\n\t\t\t\t}\n\n\t\t\t\t_applyArray((key, val) => {\n\t\t\t\t\tnode.setAttribute(key, val)\n\t\t\t\t})\n\n\t\t\t\treturn applyValue;\n\t\t\t})\n\t\t\tif ([\"@\", \".\", \"?\", \"!\"].indexOf(nameStart) !== -1 || name.match(MATCH_MULTI_CHAR)) {\n\t\t\t\tnode.removeAttribute(name)\n\t\t\t} else if (name !== \"ref\") {\n\t\t\t\tnode.setAttribute(name, value)\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Check text nodes, append HTML if necessary\n\t\t */\n\t\tvar childNodes = Array.from(node.childNodes);\n\t\tfor (const children of childNodes) {\n\t\t\tif (children.nodeType === Node.TEXT_NODE) {\n\t\t\t\tvar innerText = children.wholeText;\n\t\t\t\tif (!hasParent(children, \"PRE\")) {\n\t\t\t\t\tinnerText = innerText.trim()\n\t\t\t\t}\n\t\t\t\tconst matchArray = Array.from(innerText.matchAll(MATCH_INDEX_REGEX));\n\t\t\t\tinnerText = innerText.replace(MATCH_INDEX_REGEX, (i) => {\n\t\t\t\t\treturn \" \".repeat(i.length)\n\t\t\t\t})\n\t\t\t\tif (matchArray.length > 0) {\n\t\t\t\t\tchildren.textContent = \"\"\n\t\t\t\t}\n\t\t\t\tvar lastOffsetIndex = 0;\n\t\t\t\tfor (let i = 0; i < matchArray.length; i++) {\n\t\t\t\t\tconst match = matchArray[i];\n\t\t\t\t\tvar index = parseInt(match[1]);\n\t\t\t\t\tvar value = vars[index];\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Insert text before the element if existed beforehand.\n\t\t\t\t\t */\n\t\t\t\t\tvar insertBefore = innerText.substring(lastOffsetIndex, match.index);\n\t\t\t\t\tif (insertBefore !== \"\") {\n\t\t\t\t\t\tinsertText(node, insertBefore)\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t * Object is no primitive, handle differently\n\t\t\t\t\t */\n\t\t\t\t\tconst appendNonPrimitive = (value) => {\n\t\t\t\t\t\tif (value instanceof HTMLElement || value instanceof SVGElement || value instanceof Text) {\n\t\t\t\t\t\t\tvar span = document.createElement(\"span\")\n\t\t\t\t\t\t\tspan.insertAfter(children)\n\t\t\t\t\t\t\tspan.replaceWith(value)\n\t\t\t\t\t\t} else if (value instanceof HTMLCollection || value instanceof NodeList) {\n\t\t\t\t\t\t\tvar span = document.createElement(\"span\")\n\t\t\t\t\t\t\tspan.insertAfter(children)\n\t\t\t\t\t\t\tspan.replaceWith(...value)\n\t\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\t\tvalue.reverse().map(x => appendNonPrimitive(x))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (value !== Object(value) || value instanceof _shared_internals_js__WEBPACK_IMPORTED_MODULE_1__.ValueBinder) {\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * Handle primitive, simple insert\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tinsertText(node, value)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconsole.error('Value might not be supported...')\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tappendNonPrimitive(value)\n\n\t\t\t\t\tif (i == matchArray.length - 1) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Last element, append rest of string.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tchildren.remove()\n\t\t\t\t\t\tvar insertAfter = innerText.substring(match.index + match[0].length)\n\t\t\t\t\t\tif (insertAfter != \"\") {\n\t\t\t\t\t\t\tinsertText(node, insertAfter)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlastOffsetIndex = match.index + value && value.length\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Loop through all children again and render components\n\t */\n\tvar childNodes = Array.from(template.content.childNodes).map(x => x.getElementsByTagName && Array.from(x.getElementsByTagName(\"*\"))).flat()\n\tfor (const children of childNodes) {\n\t\tlet component;\n\t\tif (children && children.tagName && (component = window.exposedComponents[children.tagName.toLowerCase()])) {\n\t\t\tvar attributeValues = _snowblind_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getNodeProperties(children);\n\t\t\tnew component(attributeValues, {\n\t\t\t\treplace: children,\n\t\t\t\timplementedEvents: children._savedEvents || []\n\t\t\t})\n\t\t}\n\t}\n\treturn template.content.children[0]\n}\n\nfunction repeat(items, itemTemplate, keyFunction = () => {}) {\n\tvar arr = []\n\tfor (const i in items) {\n\t\tconst item = items[i];\n\t\tvar uniqueKey = keyFunction(i, item);\n\t\tarr.push(itemTemplate(i, item, uniqueKey));\n\t}\n\treturn arr\n}\n\nfunction classMap(classes) {\n\tvar classNames = []\n\tfor (const key in classes) {\n\t\tconst evaluationProperty = classes[key];\n\t\tif (evaluationProperty) {\n\t\t\tclassNames.push(key)\n\t\t}\n\t}\n\treturn classNames.join(\" \").trim();\n}\n\n/**\n * Takes an array of classes and returns them as string if they evaluate to true.\n * @param {Array} classes Array of classes to be checked\n * @returns {String}\n */\nfunction classArray(classes) {\n\treturn classMap(Object.fromEntries(classes.map(x => {\n\t\tif (Array.isArray(x)) {\n\t\t\treturn Array.isArray(x[0]) ? x[0].map(y => [y, x[1]]) : x;\n\t\t} else {\n\t\t\treturn [x, x ? true : false]\n\t\t}\n\t})))\n}\n\nfunction styleMap(styles) {\n\tvar string = \"\";\n\tfor (const i in styles) {\n\t\tstring += styles[i] ? `${i}: ${styles[i]};` : \"\";\n\t}\n\treturn string;\n}\n\nfunction when(condition, evaluateTrue, evaluateFalse) {\n\treturn condition ? evaluateTrue() : evaluateFalse();\n}\n\nfunction choose(prop, options, fallback) {\n\tif (options.hasOwnProperty(prop)) {\n\t\treturn options[prop](prop);\n\t}\n\treturn fallback()\n}\n\nfunction range(start, end, step = 1) {\n\treturn Array((end - start) / step).fill(0).map((x, i) => i * step + start)\n}\n\n/**\n * Takes a condition and element only returns it if the condition is true.\n * @param {any} condition The condition to be checked\n * @param {any} element The return value if the condition is true\n * @returns {any | String}\n */\nfunction elemIf(condition, element) {\n\treturn condition ? element : \"\";\n}\n/**\n * Inserts a given element after another.\n * @param {HTMLElement} el The element given node should be inserted after.\n */\nHTMLElement.prototype.insertAfter = function (el) {\n\tif (el && el.parentNode) {\n\t\tel.parentNode.insertBefore(this, el.nextSibling);\n\t}\n};\n\n\n\n//# sourceURL=webpack://snowblind/./src/html.js?");

/***/ }),

/***/ "./src/observer.js":
/*!*************************!*\
  !*** ./src/observer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Observer\": () => (/* binding */ Observer)\n/* harmony export */ });\nclass Observer {\n\t/**\n\t * Instantiates a proxy based on a passed object supporting rerendering of components.\n\t * @param {object} value The object a proxy should be attached to.\n\t */\n\tconstructor(value, onlyHasValue = false) {\n\t\tthis.ID = Math.random().toString(36).substring(2, 15);\n\t\tthis.boundRender = undefined\n\t\tconst _Handler = {\n\t\t\tget(target, key) {\n\t\t\t\tif (key == '__isProxy') {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\n\t\t\t\tconst prop = target[key];\n\t\t\t\tif (typeof prop == 'undefined') {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// set value as proxy if object\n\t\t\t\tif (prop !== null) {\n\t\t\t\t\tvar constructor = prop.constructor;\n\t\t\t\t\tif (!prop.__isProxy && constructor && ((constructor === ({}).constructor) || (constructor === ([]).constructor))) {\n\t\t\t\t\t\ttarget[key] = new Proxy(prop, _Handler);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn target[key];\n\t\t\t},\n\t\t\tset: (x, y, z) => {\n\t\t\t\ttry {\n\t\t\t\t\tx[y] = JSON.parse(z)\n\t\t\t\t} catch (e) {\n\t\t\t\t\tx[y] = z\n\t\t\t\t}\n\t\t\t\tif (this.boundRender) {\n\t\t\t\t\tif (this.debounce) {\n\t\t\t\t\t\twindow.cancelAnimationFrame(this.debounce);\n\t\t\t\t\t}\n\t\t\t\t\tthis.debounce = window.requestAnimationFrame(() => {\n\t\t\t\t\t\tthis.boundRender.Render()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tthis._value = new Proxy(value, _Handler);\n\t\tif (onlyHasValue === true) {\n\t\t\tthis._value.toString = () => {\n\t\t\t\treturn this._value.value\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n//# sourceURL=webpack://snowblind/./src/observer.js?");

/***/ }),

/***/ "./src/render-assignment.js":
/*!**********************************!*\
  !*** ./src/render-assignment.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RenderAssignment)\n/* harmony export */ });\n/* harmony import */ var _snowblind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./snowblind.js */ \"./src/snowblind.js\");\n\n\nclass RenderAssignment {\n\tconstructor(obj, options = {}) {\n\t\tobj._Observer.boundRender = this\n\t\tthis._wasDestroyed = false;\n\t\tthis.copiesKeptAlive = 0;\n\t\tthis.lastNode;\n\t\tthis.Node;\n\t\tthis.ID = Math.random().toString(36).substring(2, 15);\n\t\t/**\n\t\t * Create a linking placeholder\n\t\t */\n\t\tvar Link = document.createElement(\"span\");\n\t\tLink.classList.add(\"render-placeholder\");\n\t\tLink.setAttribute(\"render-is-linked-to\", this.ID);\n\t\tif (options.replace instanceof HTMLElement) {\n\t\t\toptions.replace.replaceWith(Link);\n\t\t} else {\n\t\t\tdocument.body.appendChild(Link);\n\t\t}\n\t\tthis.LinkedTo = Link\n\t\tthis.Object = obj\n\t\tif (!(obj instanceof _snowblind_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Component)) {\n\t\t\tthrow new Error(\"Renderer didn't receive object of type Snowblind.Component\");\n\t\t}\n\t\tthis._renderIsFirstTime = true\n\t}\n\n\tRender() {\n\t\tif (this._wasDestroyed) {\n\t\t\t/**\n\t\t\t * Destroy method has been called, cancel the render\n\t\t\t */\n\t\t\tthrow new Error(\"Renderer has been destroyed.\")\n\t\t}\n\t\tvar maxCopies = this.Object.transitionMaxCopies;\n\n\t\tif (this._renderIsFirstTime === false) {\n\t\t\t/**\n\t\t\t * Assign childElements\n\t\t\t */\n\t\t\tthis.Object.originalChildren = this.Node.childNodes;\n\t\t}\n\n\t\tif (this.Object.usesTransition) {\n\t\t\tconst currentNode = this.Node;\n\t\t\tif (this.copiesKeptAlive >= maxCopies) {\n\t\t\t\tcurrentNode.remove()\n\t\t\t} else {\n\t\t\t\tthis.Object.transitionFunction.leave(() => {\n\t\t\t\t\tcurrentNode.remove()\n\t\t\t\t\tthis.copiesKeptAlive -= 1\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Give access to parent element\n\t\t */\n\t\tthis.Object.parentElement = this.LinkedTo.parentNode;\n\t\tvar obj = this.Object.getNode()\n\t\tif (obj instanceof HTMLElement) {\n\t\t\t/**\n\t\t\t * Keep eventListeners and append directly as HTMLElement\n\t\t\t */\n\t\t\tthis.Node = obj\n\t\t} else {\n\t\t\tthrow new Error(\"Can only initialize object with type of HTMLElement.\")\n\t\t}\n\t\t/**\n\t\t * Reset nodes on base object\n\t\t */\n\t\tthis.Object.Node = this.Node\n\t\tvar Node = this.Node\n\t\tif (this.lastNode) {\n\t\t\tconst activeElement = document.activeElement;\n\t\t\tconst selectionStart = activeElement.selectionStart;\n\t\t\tconst selectionEnd = activeElement.selectionEnd;\n\t\t\tthis.lastNode.replaceWith(Node);\n\t\t\tif (activeElement) {\n\t\t\t\tconst key = activeElement.getAttribute(\"key\");\n\t\t\t\tif (key) {\n\t\t\t\t\tconst focusNode = Node.querySelector(`[key='${key}']`)\n\t\t\t\t\tfocusNode.focus();\n\t\t\t\t\tfocusNode.setSelectionRange(selectionStart, selectionEnd)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.LinkedTo.replaceWith(Node);\n\t\t}\n\t\tthis.lastNode = Node;\n\t\t/**\n\t\t * Provide node to the component\n\t\t */\n\n\t\tif (this.Object.usesTransition) {\n\t\t\t/**\n\t\t\t * Apply any transition effects to the node\n\t\t\t */\n\t\t\tthis.copiesKeptAlive++\n\t\t\tthis.Object.transitionFunction.from(() => {\n\t\t\t\tif (!this._renderIsFirstTime) {\n\t\t\t\t\tthis.Object.transitionFunction.render()\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\n\n\t\tif (this.Object.hasTheme) {\n\t\t\t/**\n\t\t\t * Apply custom styling\n\t\t\t */\n\t\t\tconst compareStyles = document.createElement(\"div\");\n\t\t\tconst appendStyles = (elements, query) => {\n\t\t\t\tconst properties = this.Object.hasTheme[query];\n\t\t\t\tfor (const subNode of Array.from(elements)) {\n\t\t\t\t\tif (typeof properties === \"object\") {\n\t\t\t\t\t\tfor (const propName in properties) {\n\t\t\t\t\t\t\tsubNode.style[propName] = properties[propName]\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubNode.style[query] = properties\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const query in this.Object.hasTheme) {\n\t\t\t\tconst elements = Node.querySelectorAll(query)\n\t\t\t\tif (elements && elements.length > 0) {\n\t\t\t\t\tappendStyles(elements, query)\n\t\t\t\t} else if (typeof compareStyles.style[query] !== \"undefined\") {\n\t\t\t\t\tappendStyles(Array.from(Node.getElementsByTagName(\"*\")).concat([Node]), query)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._renderIsFirstTime === true) {\n\t\t\t/**\n\t\t\t * Component is only mounted AFTER the render finishes\n\t\t\t */\n\t\t\tthis.Object.componentDidMount()\n\t\t\tfor (const listener of this.Object.didMountCallbacks) {\n\t\t\t\tlistener()\n\t\t\t}\n\t\t\tthis._renderIsFirstTime = false\n\t\t} else {\n\t\t\t/**\n\t\t\t * Run componentDidUpdate() method AFTER component rerender\n\t\t\t */\n\t\t\tthis.Object.componentDidUpdate()\n\t\t\tfor (const listener of this.Object.didUpdateCallbacks) {\n\t\t\t\tlistener()\n\t\t\t}\n\t\t}\n\t}\n\n\treinitialize() {\n\t\t/**\n\t\t * Build the render again (reset render status and call constructor)\n\t\t */\n\t\tthis._renderIsFirstTime = true\n\t\tthis.constructor(this.Object)\n\t}\n\n\tDestroy() {\n\t\t/**\n\t\t * Unmount component then remove node and linking element\n\t\t */\n\t\tthis._wasDestroyed = true\n\t\tthis.Object.componentWillUnmount()\n\t\tif (this.Object.usesTransition) {\n\t\t\tthis.Object.transitionFunction.leave(() => {\n\t\t\t\tthis.Node.remove()\n\t\t\t})\n\t\t} else {\n\t\t\tthis.Node.remove()\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack://snowblind/./src/render-assignment.js?");

/***/ }),

/***/ "./src/shared-internals.js":
/*!*********************************!*\
  !*** ./src/shared-internals.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Observable\": () => (/* binding */ Observable),\n/* harmony export */   \"UpdateDispatcher\": () => (/* binding */ UpdateDispatcher),\n/* harmony export */   \"ValueBinder\": () => (/* binding */ ValueBinder)\n/* harmony export */ });\nclass Observable {\n\tconstructor(value) {\n\t\tthis._value = value;\n\t\tthis._subscribers = [];\n\t}\n\n\tnext(value) {\n\t\tthis._value = value;\n\t\tfor (const subscriber of this._subscribers) {\n\t\t\tsubscriber(value)\n\t\t}\n\t}\n\n\tsubscribe(callback) {\n\t\tthis._subscribers.push(callback);\n\t}\n\n\tcomplete() {\n\t\tthis._subscribers = new Proxy([], {set: () => {\n\t\t\tthrow new Error(\"Observable has been completed.\")\n\t\t}});\n\t}\n\n\trestore() {\n\t\tthis._subscribers = [];\n\t\tthis._value = undefined;\n\t}\n}\n\nclass ValueBinder {\n\tconstructor(obs) {\n\t\tthis.observable = obs;\n\t\tthis.value = obs._value;\n\n\t\tobs.subscribe((val) => {\n\t\t\tthis.value = val\n\t\t})\n\t}\n\n\tvalueOf() {\n\t\treturn this.value\n\t}\n\n\ttoString() {\n\t\treturn this.value.toString()\n\t}\n};\n\nconst UpdateDispatcher = new Observable();\n\n\n\n//# sourceURL=webpack://snowblind/./src/shared-internals.js?");

/***/ }),

/***/ "./src/snowblind.js":
/*!**************************!*\
  !*** ./src/snowblind.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _render_assignment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render-assignment.js */ \"./src/render-assignment.js\");\n/* harmony import */ var _observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observer.js */ \"./src/observer.js\");\n/* harmony import */ var _modules_typecheck_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/typecheck.js */ \"./modules/typecheck.js\");\n/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./html.js */ \"./src/html.js\");\n/* harmony import */ var _shared_internals_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared-internals.js */ \"./src/shared-internals.js\");\n\n\n\n\n\n\nwindow.exposedComponents = {};\n\nvar style = document.createElement(\"style\");\nstyle.innerHTML = \".render-placeholder {display:none;}\"\ndocument.head.appendChild(style)\n\n/**\n * Exposes a component to be grabbed by the initial render process.\n * @param {Array<Snowblind.Component>} components List of components to add\n * @param {Array<String>} optNames Optional list of names if they shall not be auto-retrieved from the components class name.\n */\nwindow.expose = function (components, optNames) {\n\tcomponents = Array.from([components]).flat();\n\toptNames = Array.from([optNames]).flat()\n\n\tfor (let i = 0; i < components.length; i++) {\n\t\tconst component = components[i];\n\t\tvar name = (typeof optNames[i] === \"undefined\" ? component.name : optNames[i]).toLowerCase();\n\t\twindow.exposedComponents[name] = component;\n\t}\n}\n\n/**\n * Add component to global scope;\n */\n\nconst Snowblind = {\n\tComponent: class Component {\n\t\tconstructor(obj, options = {}) {\n\t\t\toptions = Object.assign({\n\t\t\t\treplace: false,\n\t\t\t\tisFunctionProps: {},\n\t\t\t\thasTheme: false,\n\t\t\t}, options)\n\n\t\t\tthis.createdReferences = {} // All references to nodes created with (useRef())\n\t\t\tthis.globalSelf = window.exposedComponents[this.constructor.name.toLowerCase()];\n\t\t\t/**\n\t\t\t * Convert expected properties\n\t\t\t */\n\t\t\tif (this.globalSelf) {\n\t\t\t\tconst propTypes = this.globalSelf.propTypes;\n\t\t\t\tif (propTypes) {\n\t\t\t\t\tobj = (0,_modules_typecheck_js__WEBPACK_IMPORTED_MODULE_2__.typeCheck)(obj, propTypes, this.globalSelf.defaultProps)\n\t\t\t\t\tthis.unexpectedArguments = {}\n\t\t\t\t\tfor (const typeName in obj) {\n\t\t\t\t\t\tvar value = obj[typeName];\n\t\t\t\t\t\tif (!propTypes.hasOwnProperty(typeName)) {\n\t\t\t\t\t\t\tthis.unexpectedArguments[typeName] = value;\n\t\t\t\t\t\t\tdelete obj[typeName];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Custom theme when object created from styled() function\n\t\t\t */\n\t\t\tthis.hasTheme = options.hasTheme;\n\t\t\tthis._watchingObservers = []\n\t\t\tthis.transitionMaxCopies = Infinity;\n\t\t\t/**\n\t\t\t * Check if obj is a function, then it needs execution\n\t\t\t */\n\t\t\tthis._isFunction = typeof obj === 'function';\n\t\t\tthis.usesTransition = false\n\n\t\t\t/**\n\t\t\t * Setup arrays for event listening\n\t\t\t */\n\t\t\tthis.didMountCallbacks = []\n\t\t\tthis.didUpdateCallbacks = []\n\n\t\t\tvar baseOptions = this.initWith()\n\t\t\t/**\n\t\t\t * Initialize empty dependencies object for useEffect calls\n\t\t\t */\n\t\t\tthis._Observer = new _observer_js__WEBPACK_IMPORTED_MODULE_1__.Observer(obj || baseOptions)\n\t\t\tthis.props = this._Observer._value\n\t\t\tif (options.replace instanceof HTMLElement) {\n\t\t\t\tthis.originalElement = options.replace\n\t\t\t\tthis.originalChildren = Array.from(options.replace.childNodes);\n\t\t\t}\n\n\t\t\tthis.Renderer = new _render_assignment_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this, options)\n\n\t\t\tif (this._isFunction) {\n\t\t\t\tthis._generatorFunction = obj(options.isFunctionProps)\n\t\t\t\t/**\n\t\t\t\t * Write component to the UpdateDispatcher to be captured by any hooks, close immediately after.\n\t\t\t\t */\n\t\t\t\t_shared_internals_js__WEBPACK_IMPORTED_MODULE_4__.UpdateDispatcher.next(this);\n\t\t\t\t//UpdateDispatcher.restore();\n\t\t\t}\n\t\t\t\n\t\t\tfor (const i of this._watchingObservers) {\n\t\t\t\ti.boundRender = this.Renderer\n\t\t\t}\n\t\t\t/**\n\t\t\t * Initialization happens right before any render assignment is executed\n\t\t\t */\n\t\t\tthis.__init__()\n\t\t\tthis.Renderer.Render()\n\t\t}\n\n\t\tuseTransition(obj, options) {\n\t\t\t/**\n\t\t\t * Animates the render cycle given CSS properties\n\t\t\t */\n\t\t\toptions = Object.assign({\n\t\t\t\tdelay: 0,\n\t\t\t\tduration: 400,\n\t\t\t\tmaxCopies: Infinity,\n\t\t\t\tcustomTiming: (t, b, c, d) => {\n\t\t\t\t\t// Default easeInOutSine function\n\t\t\t\t\treturn -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n\t\t\t\t}\n\t\t\t}, options)\n\t\t\tthis.transitionMaxCopies = options.maxCopies\n\t\t\tthis.usesTransition = true\n\t\t\tconst animateChange = (from, to, nodes) => {\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tconst StartTime = performance.now()\n\t\t\t\t\t\tconst matchRegExp = new RegExp(/([0-9.-]+)([A-z%]+)?/g)\n\t\t\t\t\t\tconst convert = (i) => [undefined, null].indexOf(i) == -1 && i.toString().matchAll(matchRegExp);\n\t\t\t\t\t\tconst interval = (lastExpectedCycle = false) => {\n\t\t\t\t\t\t\tconst elapsed = performance.now() - StartTime;\n\t\t\t\t\t\t\tif (elapsed >= options.duration) {\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * Run one last time to clear lastly updated properties\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tif (!lastExpectedCycle) {\n\t\t\t\t\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\t\t\t\t\tinterval(true)\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\t\t\t\tinterval()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const i in to) {\n\t\t\t\t\t\t\t\tvar End = Array.from(convert(to[i]));\n\t\t\t\t\t\t\t\tif ([undefined, null].indexOf(from[i]) == -1) {\n\t\t\t\t\t\t\t\t\tvar j = 0;\n\t\t\t\t\t\t\t\t\tvar replaced = from[i].toString().replace(matchRegExp, (x, num, unit) => {\n\t\t\t\t\t\t\t\t\t\tnum = parseFloat(num)\n\t\t\t\t\t\t\t\t\t\tvar _to = parseFloat(End[j][1])\n\t\t\t\t\t\t\t\t\t\tj++\n\t\t\t\t\t\t\t\t\t\tvar standardUnit = ([\"color\", \"background\", \"background-color\"].indexOf(i) === -1) ? \"px\" : \"\"\n\t\t\t\t\t\t\t\t\t\treturn options.customTiming(elapsed, num, _to - num, options.duration).toString() + (unit || End[j - 1][2] || standardUnit)\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\tfor (const node of nodes) {\n\t\t\t\t\t\t\t\t\t\tnode[0].style[i] = replaced\n\t\t\t\t\t\t\t\t\t\tif (lastExpectedCycle) {\n\t\t\t\t\t\t\t\t\t\t\tnode[0].style[i] = to[i]\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\t\tinterval()\n\t\t\t\t\t\t})\n\t\t\t\t\t}, options.delay)\n\t\t\t\t})\n\t\t\t}\n\t\t\tthis.transitionFunction = {\n\t\t\t\tfrom: (callback) => {\n\t\t\t\t\tfor (const i in obj.from) {\n\t\t\t\t\t\tthis.Nodes.map(x => x[0].style[i] = obj.from[i])\n\t\t\t\t\t}\n\t\t\t\t\tcallback()\n\t\t\t\t},\n\t\t\t\trender: (callback) => {\n\t\t\t\t\tanimateChange(obj.render, obj.enter, this.Nodes).then(callback)\n\t\t\t\t},\n\t\t\t\tenter: (callback) => {\n\t\t\t\t\tanimateChange(obj.from, obj.enter, this.Nodes).then(callback)\n\t\t\t\t},\n\t\t\t\tleave: (callback) => {\n\t\t\t\t\tanimateChange(obj.enter, obj.leave, this.Nodes).then(callback)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfadeOutDestroy(duration = 400) {\n\t\t\t/**\n\t\t\t * Debounce for performance\n\t\t\t */\n\t\t\tvar startTime = performance.now()\n\t\t\tconst interval = () => {\n\t\t\t\tvar elapsed = performance.now() - startTime;\n\t\t\t\tif (elapsed >= duration) {\n\t\t\t\t\tthis.destroy()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tthis.Nodes.map(x => x[0].style.opacity = 1 - (elapsed / duration))\n\t\t\t\trequestAnimationFrame(interval)\n\t\t\t}\n\t\t\trequestAnimationFrame(interval)\n\t\t}\n\n\t\tonComponentDidMount(callback) {\n\t\t\tthis.didMountCallbacks.push(callback)\n\t\t}\n\n\t\tonComponentDidUpdate(callback) {\n\t\t\tthis.didUpdateCallbacks.push(callback)\n\t\t}\n\n\t\tcomponentDidUpdate() {}\n\t\tcomponentDidMount() {}\n\t\tcomponentWillUnmount() {}\n\n\t\tinitWith() {\n\t\t\treturn {}\n\t\t}\n\n\t\tdestroy() {\n\t\t\tthis.Renderer.Destroy()\n\t\t\tfor (const ID in this.createdReferences) {\n\t\t\t\tdelete this.createdReferences[ID];\n\t\t\t}\n\t\t}\n\n\t\t__init__() {}\n\t\tgetNode(...args) {\n\t\t\tif (this._isFunction) {\n\t\t\t\treturn this._generatorFunction()\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t\"Could not render, are you sure you created the 'render' method according to our docs? https://continuum-ai.de/doc/snowblind/reference/render-assignment\"\n\t\t\t);\n\t\t}\n\t},\n\n\trenderAll() {\n\t\tconst getFrom = window.exposedComponents;\n\n\t\tfor (const name in getFrom) {\n\t\t\tconst property = getFrom[name]\n\t\t\tconst isFunction = typeof property === 'function'\n\t\t\tconst isComponent = property && property.prototype instanceof Snowblind.Component;\n\t\t\tif (isComponent || isFunction) {\n\t\t\t\tconst LinkedComponents = Array.from(document.getElementsByTagName(name))\n\t\t\t\tfor (const Component of LinkedComponents) {\n\t\t\t\t\t/**\n\t\t\t\t\t * Try to auto populate an entries value with a global variable or constant\n\t\t\t\t\t */\n\t\t\t\t\tconst props = Snowblind.getNodeProperties(Component)\n\t\t\t\t\tif (isFunction) {\n\t\t\t\t\t\tnew Snowblind.Component(getFrom[name], {\n\t\t\t\t\t\t\treplace: Component,\n\t\t\t\t\t\t\tisFunctionProps: props,\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnew getFrom[name](props, {\n\t\t\t\t\t\t\treplace: Component\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetNodeProperties(node) {\n\t\treturn Object.fromEntries(Array.from(node.attributes).map(x => {\n\t\t\tvar attributeValue = x.value,\n\t\t\t\tattributeName = x.name;\n\t\t\tlet Value;\n\t\t\tif ((Value = attributeValue.match(/\\{\\{([A-z0-9_ ]*?)\\}\\}/))) {\n\t\t\t\t/**\n\t\t\t\t * Try to assign a constant when finding this: \"{{constantName}}\"\n\t\t\t\t */\n\t\t\t\tvar constantName = Value[1].trim(),\n\t\t\t\t\ttype = typeof window[constantName]\n\t\t\t\tif (type !== \"undefined\" && type !== \"function\") {\n\t\t\t\t\tattributeValue = window[constantName]\n\t\t\t\t} else if (type === \"function\") {\n\t\t\t\t\tattributeValue = constantName + constantName.endsWith(\"()\") ? \"\" : \"()\"\n\t\t\t\t}\n\t\t\t} else if (attributeName.startsWith(\":\")) {\n\t\t\t\t/**\n\t\t\t\t * User passed HTML as attribute, convert to node\n\t\t\t\t */\n\t\t\t\tvar attributeValue = (0,_html_js__WEBPACK_IMPORTED_MODULE_3__.html)([attributeValue]);\n\t\t\t\tattributeName = attributeName.substring(1)\n\t\t\t} else if (attributeValue.startsWith(\"{\") && attributeValue.endsWith(\"}\")) {\n\t\t\t\tvar innerValue = attributeValue.substring(1, attributeValue.length - 1)\n\t\t\t\tif (innerValue === \"true\" || innerValue === \"false\") {\n\t\t\t\t\t/**\n\t\t\t\t\t * Try to match the value to a typical datatype\n\t\t\t\t\t */\n\t\t\t\t\tattributeValue = innerValue === \"true\" ? true : false;\n\t\t\t\t} else if (parseFloat(innerValue) == innerValue) {\n\t\t\t\t\tattributeValue = parseFloat(innerValue)\n\t\t\t\t}\n\t\t\t} else if (attributeValue.startsWith(\"[\") && attributeValue.endsWith(\"]\")) {\n\t\t\t\t/**\n\t\t\t\t * Make an array\n\t\t\t\t */\n\t\t\t\tattributeValue = JSON.parse(attributeValue.replace(/(?<!\\\\)'/g, '\"'));\n\t\t\t}\n\t\t\t/**\n\t\t\t * style can not be used, circumvent by adding _ in front, has to be removed here\n\t\t\t */\n\t\t\treturn [attributeName.startsWith(\"_\") ? attributeName.substring(1) : attributeName, attributeValue]\n\t\t}))\n\t},\n\teventBus: {\n\t\ton(event, callback) {\n\t\t\tdocument.addEventListener(event, (e) => callback(e.detail));\n\t\t},\n\t\tdispatch(event, data) {\n\t\t\tdocument.dispatchEvent(new CustomEvent(event, {\n\t\t\t\tdetail: data\n\t\t\t}));\n\t\t},\n\t\tremove(event, callback) {\n\t\t\tdocument.removeEventListener(event, callback);\n\t\t},\n\t}\n}\n\nwindow.addEventListener(\"load\", () => {\n\tSnowblind.renderAll()\n})\n\n/**\n * Inserts a given element after another.\n * @param {HTMLElement} el The element given node should be inserted after.\n */\nHTMLElement.prototype.insertAfter = function (el) {\n\tif (el && el.parentNode) {\n\t\tel.parentNode.insertBefore(this, el.nextSibling);\n\t}\n};\n\n/* EventTarget.prototype.originalAddEvent = EventTarget.prototype.addEventListener;\nEventTarget.prototype.originalRemoveEvent = EventTarget.prototype.removeEventListener;\n\nEventTarget.prototype.addEventListener = function (...args) {\n\tvar eventType = args[0];\n\tif (!this._savedEvents) {\n\t\tthis._savedEvents = {};\n\t}\n\tif (!this._savedEvents[eventType]) {\n\t\tthis._savedEvents[eventType] = [];\n\t}\n\tthis._savedEvents[eventType].push(args)\n\tconsole.log(this.originalAddEvent);\n\tthis.originalAddEvent(...args)\n}\n\nEventTarget.prototype.removeEventListener = function (...args) {\n\tvar eventType = args[0];\n\tif (args[1] && this._savedEvents) {\n\t\tvar events = this._savedEvents[eventType];\n\t\tif (events) {\n\t\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\t\tconst eventArray = events[i];\n\t\t\t\tif (eventArray[1] == args[1]) {\n\t\t\t\t\tdelete events[i]\n\t\t\t\t\tthis._savedEvents[eventType] = events.filter(x => x)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tthis.originalRemoveEvent(...args)\n} */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Snowblind);\n\n//# sourceURL=webpack://snowblind/./src/snowblind.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./index.js");
/******/ var __webpack_exports__default = __webpack_exports__["default"];
/******/ export { __webpack_exports__default as default };
/******/ 
